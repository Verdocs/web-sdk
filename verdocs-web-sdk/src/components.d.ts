/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { IActivityEntry, ICreateEnvelopeRole, IEnvelope, IEnvelopeSummary, IFileWithData, IGetTemplateSummarySortBy, IOrganization, IProfile, IRole, ITemplate, ITemplateField, ITemplateFieldSetting, TEnvelopeStatus, TRecipientStatus, TTemplateSenderType, VerdocsEndpoint } from "@verdocs/js-sdk";
import { SDKError } from "./utils/errors";
import { IAuthStatus } from "./components/embeds/verdocs-auth/verdocs-auth";
import { TVerdocsBuildStep } from "./components/embeds/verdocs-build/verdocs-build";
import { IContactSearchEvent, IContactSelectEvent, IEmailContact, IPhoneContact } from "./components/envelopes/verdocs-contact-picker/verdocs-contact-picker";
import { IMenuOption } from "./components/controls/verdocs-dropdown/verdocs-dropdown";
import { IDocumentPageInfo, IPageLayer } from "./utils/Types";
import { IFilterOption } from "./components/controls/verdocs-quick-filter/verdocs-quick-filter";
import { ISearchEvent, TContentType } from "./components/elements/verdocs-search-box/verdocs-search-box";
import { IContactSearchEvent as IContactSearchEvent1 } from "./components/envelopes/verdocs-contact-picker/verdocs-contact-picker";
import { IColumn } from "./components/controls/verdocs-table/verdocs-table";
import { ITab } from "./components/controls/verdocs-tabs/verdocs-tabs";
import { TVerdocsBuildStep as TVerdocsBuildStep1 } from "./components/templates/verdocs-template-build-tabs/verdocs-template-build-tabs";
import { TAllowedTemplateAction } from "./components/templates/verdocs-templates-list/verdocs-templates-list";
import { IToggleIconButtons } from "./components/controls/verdocs-toggle/verdocs-toggle";
import { Placement } from "@popperjs/core/lib/enums";
export { IActivityEntry, ICreateEnvelopeRole, IEnvelope, IEnvelopeSummary, IFileWithData, IGetTemplateSummarySortBy, IOrganization, IProfile, IRole, ITemplate, ITemplateField, ITemplateFieldSetting, TEnvelopeStatus, TRecipientStatus, TTemplateSenderType, VerdocsEndpoint } from "@verdocs/js-sdk";
export { SDKError } from "./utils/errors";
export { IAuthStatus } from "./components/embeds/verdocs-auth/verdocs-auth";
export { TVerdocsBuildStep } from "./components/embeds/verdocs-build/verdocs-build";
export { IContactSearchEvent, IContactSelectEvent, IEmailContact, IPhoneContact } from "./components/envelopes/verdocs-contact-picker/verdocs-contact-picker";
export { IMenuOption } from "./components/controls/verdocs-dropdown/verdocs-dropdown";
export { IDocumentPageInfo, IPageLayer } from "./utils/Types";
export { IFilterOption } from "./components/controls/verdocs-quick-filter/verdocs-quick-filter";
export { ISearchEvent, TContentType } from "./components/elements/verdocs-search-box/verdocs-search-box";
export { IContactSearchEvent as IContactSearchEvent1 } from "./components/envelopes/verdocs-contact-picker/verdocs-contact-picker";
export { IColumn } from "./components/controls/verdocs-table/verdocs-table";
export { ITab } from "./components/controls/verdocs-tabs/verdocs-tabs";
export { TVerdocsBuildStep as TVerdocsBuildStep1 } from "./components/templates/verdocs-template-build-tabs/verdocs-template-build-tabs";
export { TAllowedTemplateAction } from "./components/templates/verdocs-templates-list/verdocs-templates-list";
export { IToggleIconButtons } from "./components/controls/verdocs-toggle/verdocs-toggle";
export { Placement } from "@popperjs/core/lib/enums";
export namespace Components {
    /**
     * Displays a box showing summaries of envelopes matching specified conditions. Activity Boxes show a fixed number
     * of items because they are meant to be laid out horizontally (if the user's screen is large enough) and this helps
     * them appear more visually balanced.
     */
    interface VerdocsActivityBox {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The title to display on the box ("title" is a reserved word). This is optional, and if not set, the title will be derived from the view. Set this to an empty string to hide the header.
         */
        "header"?: string | undefined;
        /**
          * The number of items to display.
         */
        "items": number;
        /**
          * The filtered view to display. "completed" will show envelopes that have been submitted. "action" will show envelopes where the user is a recipient and the envelope is not completed. "waiting" will show only envelopes where the user is the sender and the envelope is not completed.
         */
        "view"?: 'completed' | 'action' | 'waiting';
    }
    /**
     * Display an authentication dialog that allows the user to login or sign up. If the user is already authenticated
     * with a valid session, this component will hide itself and fire the success callback immediately. It is up to the
     * host application to render the next appropriate view for the application.
     * To simplify UI development, a visibility flag can force this component to never display. This
     * allows you to susbcribe to notifications from client apps without calling the lower-level JS SDK.
     * This embed is responsive / mobile-friendly, but the calling application should provide at least a 300px wide
     * container to allow sufficient space for the required forms.
     * ```ts
     * <verdocs-auth onAuthenticated={e => console.log('Authentication state:', e.detail)} />
     * ```
     */
    interface VerdocsAuth {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * By default, a Verdocs logo will be displayed above the login/signup forms. This may be used to override its source. (Alternatively, you may simply hide it via CSS overrides.) Logos should be in SVG format for best results.
         */
        "logo": string;
        /**
          * Normally, if the user has a valid session, this embed will be invisible, otherwise it will display login / signup forms. If this is set to false, this embed will be invisible in both cases. Apps may use this to verify if a user has a valid session without needing a separate call to Verdocs JS SDK.
         */
        "visible": boolean;
    }
    /**
     * Display a template building experience.
     * ```ts
     * <verdocs-build templateId={templateId} />
     * ```
     */
    interface VerdocsBuild {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The step in the creation process to display.
         */
        "step": TVerdocsBuildStep;
        /**
          * The ID of the template to create the document from. Unlike most other components, this is an optional parameter here. If the template ID is known, `step` may also be specified to force displaying a specific step in the creation process. If it is not specified, `step` will be ignored and the create step will be shown.
         */
        "templateId": string | null;
    }
    /**
     * A simple button, with consistent styling to other controls in the design system.
     * ```ts
     * <verdocs-button label="Click Me" size="normal" variant="standard" />
     * ```
     */
    interface VerdocsButton {
        /**
          * Whether the button should be disabled.
         */
        "disabled": boolean;
        /**
          * If desired, a suffix icon for the button.
         */
        "endIcon": string | null;
        /**
          * The label for the button.
         */
        "label": string;
        /**
          * The size (height) of the button.
         */
        "size": 'small' | 'normal' | 'medium' | 'large';
        /**
          * If desired, a prefix icon for the button.
         */
        "startIcon": string | null;
        /**
          * The type of the button.
         */
        "type": 'button' | 'submit' | 'reset';
        /**
          * The display variant of the button.
         */
        "variant": 'standard' | 'text' | 'outline';
    }
    /**
     * Display an icon button that triggers a drop-down panel that can display
     * arbitrary child content, such as metadata, forms, or other controls.
     * ```ts
     *   <verdocs-button-panel .icon=${icon}>
     *     <h6>Field Settings</h6>
     *     <form>
     *     <p>
     *       <label>Field Name</label>
     *       <input type="text" placeholder="Field Name..." />
     *     </p>
     *     </form>
     *   </verdocs-button-panel>
     * ```
     */
    interface VerdocsButtonPanel {
        "hidePanel": () => Promise<void>;
        /**
          * SVG icon to display
         */
        "icon": string;
        "showPanel": () => Promise<void>;
        "toggle": () => Promise<void>;
    }
    /**
     * Displays a check box. Note that this is different from the `verdocs-field-checkbox` component, which is designed
     * to be used in signing experiences and contains settings that connect to template fields. This is just a simple check
     * box for UI displays e.g. dialog boxes.
     * This control encapsulates a standard HTML checkbox. To subscribe to change events, connect an `onChange`
     * handler. Sample usage:
     * ```ts
     * <verdocs-checkbox
     *    value="on"
     *    name="thingEnabled"
     *    checked={this.thingEnabled}
     *    onInput={(e: any) => (this.thingEnabled = e.target.checked)}
     * />
     * ```
     */
    interface VerdocsCheckbox {
        /**
          * Whether the radio button is currently selected.
         */
        "checked": boolean;
        /**
          * If set, the button will still be displayed but not selectable.
         */
        "disabled"?: boolean;
        /**
          * Label to display. Leave blank for no label. The label will be displayed to the right of the checkbox, but may be repositioned with CSS.
         */
        "label": string;
        /**
          * HTML form field name for the input.
         */
        "name": string;
        /**
          * Style of checkbox to render. Use 'dark' when rendering on a dark background.
         */
        "theme": 'light' | 'dark';
        /**
          * Value to track with the input. Value is not used internally by this component but is sometimes useful to set because it can be retrieved in event handlers via e.target.value. This can be used to identify which checkbox was clicked in a checkbox group.
         */
        "value": string;
    }
    /**
     * Render a simple error message.
     */
    interface VerdocsComponentError {
        /**
          * The message to display.
         */
        "message": string;
    }
    /**
     * Displays a contact picker suitable for filling out Recipient objects when sending Documents.
     * This picker can also be integrated with a backend to provide contact list / suggestion / address-book style behavior. As the
     * user interacts with the component, the text entered in the name field is sent back to the parent via the `searchContacts` event.
     * The parent can use that text as a query string to call a backend to obtain appropriate contacts to show. This list may also be
     * hard-coded ahead of time to provide the user with smart suggestions on initial display, such as "Recently Used" contacts, or
     * to always display the user's own contact record.
     */
    interface VerdocsContactPicker {
        /**
          * If set, suggestions will be displayed in a drop-down list to the user. It is recommended that the number of suggestions be limited to the 5 best matching records.
         */
        "contactSuggestions": (IEmailContact | IPhoneContact)[];
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The role that this contact will be assigned to.
         */
        "templateRole": IRole | null;
    }
    /**
     * Display a simple dialog where the contents are provided via slots.
     */
    interface VerdocsDialog {
    }
    /**
     * Display a drop-down menu button. A menu of the specified options will be displayed when the button is pressed. The menu will be hidden
     * when the button is pressed again, or an option is selected. Separators may be created by supplying an entry with an empty label.
     * ```ts
     * <verdocs-dropdown
     *   options={[
     *     {label: 'Option 1', disabled: true},
     *     {label: 'Option 2', id: '2'}
     *     {label: ''}
     *     {label: 'Option 3', id: '2'}
     *    ]}
     *   label="OK" onClick={() => (console.log('OK clicked'))}
     * />
     * ```
     */
    interface VerdocsDropdown {
        /**
          * The menu options to display.
         */
        "options": IMenuOption[];
    }
    /**
     * Represents one document page. This is primarily a layout container used to coordinate positions of
     * page-related layers such as the page itself, signature fields, etc. It is not intended to be used
     * on its own as an individual component.
     */
    interface VerdocsEnvelopeDocumentPage {
        /**
          * The ID of the document to display.
         */
        "documentId": string;
        /**
          * The endpoint to load from.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The ID of the envelope the document is for.
         */
        "envelopeId": string;
        /**
          * The layers that will be rendered. The DOM structure will be a DIV container with one child DIV for each layer. The parent DIV will have a unique ID, and each child DIV will have that ID with the layer name appended, e.g. if `pages` was ['page', 'fields'] the structure will be:  ```     <div id="verdocs-envelope-document-page-ker2fr1p9">       <div id="verdocs-envelope-document-page-ker2fr1p9-page"></div>       <div id="verdocs-envelope-document-page-ker2fr1p9-fields"></div>     </div> ```
         */
        "layers": IPageLayer[];
        /**
          * The page number being rendered. (Reminder: page numbers are 1-based.)
         */
        "pageNumber": number;
        "type": 'original' | 'filled' | 'certificate';
        /**
          * The "virtual" height of the page canvas.  Defaults to 792 which at 72dpi is 11" tall. This is used to compute the aspect ratio of the final rendered element when scaling up/down.
         */
        "virtualHeight": number;
        /**
          * The "virtual" width of the page canvas. Defaults to 612 which at 72dpi is 8.5" wide. This is used to compute the aspect ratio of the final rendered element when scaling up/down.
         */
        "virtualWidth": number;
    }
    /**
     * Displays a single recipient from an envelope, with the opportunity to copy an in-person
     * signing link for that recipient to use.
     */
    interface VerdocsEnvelopeRecipientLink {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The envelope ID to edit.
         */
        "envelopeId": string;
        /**
          * The role to load.
         */
        "roleName": string;
    }
    /**
     * Displays a list of recipients with options to get in-person signing links for each one.
     */
    interface VerdocsEnvelopeRecipientSummary {
        /**
          * Enable or disable the Done button.
         */
        "canDone": boolean;
        /**
          * Enable or disable the Send Another button.
         */
        "canSendAnother": boolean;
        /**
          * Enable or disable the View button.
         */
        "canView": boolean;
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The envelope ID to edit.
         */
        "envelopeId": string;
    }
    /**
     * Displays a file upload mechanism suitable for the first step of creating a template.
     * This is typically the first step in a template creation workflow.
     */
    interface VerdocsEnvelopeSidebar {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The envelope ID to render. Set ONE OF templateId or envelopeId. If both are set, envelopeId will be ignored.
         */
        "envelopeId": string;
    }
    /**
     * Displays a list of envelopes matching specified conditions.
     */
    interface VerdocsEnvelopesList {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * If set, filter envelopes by the specified string.
         */
        "match": string;
        /**
          * The number of rows to display per page.
         */
        "rowsPerPage": number;
        /**
          * The initial page number to select. Pagination is internally controlled but may be overriden by the host applicaiton.
         */
        "selectedPage": number;
        /**
          * Whether or not pagination should be enabled.
         */
        "showPagination": boolean;
        /**
          * The sort field to use
         */
        "sort": 'name' | 'created_at' | 'updated_at' | 'canceled_at' | 'status';
        /**
          * The status value to filter by
         */
        "status": TEnvelopeStatus | 'all';
        /**
          * The filtered view to display. "completed" will show envelopes that have been submitted. "action" will show envelopes where the user is a recipient and the envelope is not completed. "waiting" will show only envelopes where the user is the sender and the envelope is not completed.
         */
        "view"?: 'all' | 'inbox' | 'sent' | 'completed' | 'action' | 'waiting';
    }
    /**
     * Displays an attachment field.
     */
    interface VerdocsFieldAttachment {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used. This component self-manages its resize (width) behavior when in edit-template mode, and uses this endpoint to save changes.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The name of the field to display.
         */
        "fieldname": string;
        "focusField": () => Promise<void>;
        "hideSettingsPanel": () => Promise<void>;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        "showSettingsPanel": () => Promise<void>;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid": string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a checkbox.
     */
    interface VerdocsFieldCheckbox {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The name of the field to display.
         */
        "fieldname": string;
        "hideSettingsPanel": () => Promise<void>;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * The index of the settings option this particular checkbox is for
         */
        "option": number;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        "showSettingsPanel": () => Promise<void>;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid": string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a date field. When tapped or clicked, the input element will display a date picker component.
     */
    interface VerdocsFieldDate {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "field"?: ITemplateField;
        /**
          * The name of the field to display.
         */
        "fieldname": string;
        "focusField": () => Promise<void>;
        "hideSettingsPanel": () => Promise<void>;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        "showSettingsPanel": () => Promise<void>;
        /**
          * The template the field is for/from. Only required for the field builder, passed down to the properties component.
         */
        "templateid": string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a dropdown field that allows the user to choose one of a list of options.
     */
    interface VerdocsFieldDropdown {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The name of the field to display.
         */
        "fieldname": string;
        "focusField": () => Promise<void>;
        "hideSettingsPanel": () => Promise<void>;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        "showSettingsPanel": () => Promise<void>;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid": string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays an initial field. If an initial already exists, it will be displayed and the field
     * will be disabled. Otherwise, a placeholder button will be shown. Clicking the button will
     * show a dialog to adopt an initial.
     * NOTE: When initial fields are completed they will be filled with an initial "stamp".
     * This requires operation against a live, valid envelope. If you are testing this component
     * in Storybook, it will not be visible here.
     */
    interface VerdocsFieldInitial {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The name of the field to display.
         */
        "fieldname": string;
        "focusField": () => Promise<void>;
        "hideSettingsPanel": () => Promise<void>;
        /**
          * The document or template field to display.
         */
        "initials": string;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        "showSettingsPanel": () => Promise<void>;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid": string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a signature field. Various field types are supported, including traditional Signature and Initials types as well as
     * input types like text and checkbox.
     */
    interface VerdocsFieldPayment {
        "currentInitial": string;
        "currentInitialId": string;
        "currentSignature": string;
        "currentSignatureId": string;
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        "fieldId": string;
        /**
          * The name of the field to display.
         */
        "fieldname": string;
        "fields": any[];
        "focused": boolean;
        "hideSettingsPanel": () => Promise<void>;
        "pageNum": number;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        "pdfPages": any[];
        "recipients": any;
        "roleName": string;
        /**
          * If set, the field will be colored using this index value to select the background color.
         */
        "roleindex"?: number;
        "selectedRoleName": string;
        "showSettingsPanel": () => Promise<void>;
        "signed": boolean;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid": string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a radio button.
     */
    interface VerdocsFieldRadioButton {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The name of the field to display.
         */
        "fieldname": string;
        "hideSettingsPanel": () => Promise<void>;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * The index of the settings option this particular checkbox is for
         */
        "option": number;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        "showSettingsPanel": () => Promise<void>;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid": string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a signature field. If a signature already exists, it will be displayed and the field
     * will be disabled. Otherwise, a placeholder button will be shown. Clicking the button will
     * show a dialog to adopt a signature.
     * NOTE: When signature fields are completed they will be filled with a signature "stamp".
     * This requires operation against a live, valid envelope. If you are testing this component
     * in Storybook, it will not be visible here.
     */
    interface VerdocsFieldSignature {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The name of the field to display.
         */
        "fieldname": string;
        "focusField": () => Promise<void>;
        "hideSettingsPanel": () => Promise<void>;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * If set, the signature creation dialog will be initialized with this text.
         */
        "name"?: string;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        "showSettingsPanel": () => Promise<void>;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid": string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Display a multi-line text input field. Reminder: the "position" of the field is specified
     * as the BOTTOM-LEFT corner.
     */
    interface VerdocsFieldTextarea {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used. This component self-manages its resize (width) behavior when in edit-template mode, and uses this endpoint to save changes.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The name of the field to display.
         */
        "fieldname": string;
        "focusField": () => Promise<void>;
        "hideSettingsPanel": () => Promise<void>;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        "showSettingsPanel": () => Promise<void>;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid": string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Display a simple 1-line text input field.
     */
    interface VerdocsFieldTextbox {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used. This component self-manages its resize (width) behavior when in edit-template mode, and uses this endpoint to save changes.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The name of the field to display.
         */
        "fieldname": string;
        "focusField": () => Promise<void>;
        "hideSettingsPanel": () => Promise<void>;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        "showSettingsPanel": () => Promise<void>;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid": string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Display a timestamp. Timestamps are not editable by signers. Instead, they are automatically
     * filled when the signer submits the document.
     */
    interface VerdocsFieldTimestamp {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The name of the field to display.
         */
        "fieldname": string;
        "focusField": () => Promise<void>;
        "hideSettingsPanel": () => Promise<void>;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        "showSettingsPanel": () => Promise<void>;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid": string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a file picker to upload an attachment. This component is just the picker - the host application or component should
     * provide the actual upload functionality.
     * ```ts
     * <verdocs-file-chooser onFileSelected={(e) => console.log('File Selected', e.detail)} />
     * ```
     */
    interface VerdocsFileChooser {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
    }
    /**
     * Displays a simple help icon. Upon hover or focus, a tooltip will be displayed with help text.
     * ```ts
     * <verdocs-help-icon text="Sample help text" />
     * ```
     */
    interface VerdocsHelpIcon {
        /**
          * Optional icon to display. If not supplied, a standard help icon will be shown.
         */
        "icon": string;
        /**
          * Help text to display on hover/focus
         */
        "text": string;
    }
    /**
     * Display a dialog that allows the user to specify an initials image, either by using a signature-font-generated image
     * based on their full name, or by hand-drawing their initials with a mouse or tablet.
     */
    interface VerdocsInitialDialog {
        /**
          * Initial signature text
         */
        "initials": string;
    }
    /**
     * Prompt the user to confirm their identity with a series of questions.
     */
    interface VerdocsKbaDialog {
        /**
          * For choice challenges, a set of choices to choose from. 6 choices is recommended to fit most screen sizes.
         */
        "choices": string[];
        /**
          * If set, a help/instructions box will be displayed with this text
         */
        "helptext": string;
        /**
          * If set, a help/instructions box will be displayed with this title
         */
        "helptitle": string;
        /**
          * For text input challenges, the label to display next to the input field.
         */
        "label": string;
        /**
          * Whether the dialog is currently being displayed. This allows it to be added to the DOM before being displayed.
         */
        "mode": 'text' | 'choice';
        /**
          * For text input challenges, the placeholder to display inside the input field.
         */
        "placeholder": string;
        /**
          * Which step this confirmation is for, in a multi-step process. Ignored if `steps` is < 2.
         */
        "step": number;
        /**
          * How many steps exist in a multi-step process. Set to 1 for a single-step process (hides the indicator).
         */
        "steps": number;
    }
    /**
     * Animated loader placeholder. There are currently no configuration options for this control.
     * ```ts
     * <verdocs-loader />
     * ```
     */
    interface VerdocsLoader {
    }
    /**
     * Display a simple text dialog box with an Ok button. This adds a partially-transparent overlay and screen-centered dialog
     * box with a message and optional header/title. An OK button is shown that will dismiss the message.
     * It can also be dismissed by clicking the background overlay.
     */
    interface VerdocsOkDialog {
        /**
          * Override the "OK" button's label
         */
        "buttonLabel": string;
        /**
          * The title of the dialog. "title" is a reserved word, so we use heading.
         */
        "heading": string;
        /**
          * The message content to display.
         */
        "message": string;
        /**
          * If set, a cancel button will also be displayed. Note that the dialog is always cancelable by clicking the background overlay to dismiss it.
         */
        "showCancel": boolean;
    }
    /**
     * Display a small summary card describing an organization.
     * ```ts
     * <verdocs-organization-card organization={organization} />
     * ```
     */
    interface VerdocsOrganizationCard {
        /**
          * The organization to display
         */
        "organization": IOrganization;
    }
    /**
     * Display a simple pagination control with individual buttons to move through the data set.
     * ```ts
     * <verdocs-pagination
     *   selectedPage={1}
     *   itemCount={50}
     *   perPage={10}
     *   onSelectPage={(e) => {setSelectedpage(e.detail.selectedPage)}}
     * />
     * ```
     */
    interface VerdocsPagination {
        /**
          * The total number of items.
         */
        "itemCount": number;
        /**
          * The number of displayed per page.
         */
        "perPage": number;
        /**
          * The currently selected page.
         */
        "selectedPage": number;
    }
    /**
     * Display a child component in a "portal", popping it out of the main DOM tree
     * to allow it to escape the bounds set by its parent.
     * @credit https://github.com/tomas-teston/stencil-portal for the basic
     * technique. This has been altered in a few ways to make it more friendly
     * to cases where there may be multiple portals on the page and provide more
     * alignment options for the child to be displayed.
     * ```ts
     * <div style="padding: 40px">
     * <div id="sample-tooltip" style="border: 1px solid green; padding: 3px 10px;">
     * Tooltip Anchor
     * <verdocs-portal anchor="sample-tooltip" .align=${align} .voffset=${voffset}>
     * <div style="border: 1px solid red; padding: 3px 10px;">Tooltip</div>
     * </verdocs-portal>
     * </div>
     * </div>
     * ```
     */
    interface VerdocsPortal {
        /**
          * Horizontal alignment.
         */
        "align": 'left' | 'center' | 'right';
        /**
          * Unique ID of the parent element to anchor to.
         */
        "anchor": string;
        /**
          * Vertical offset from the parent.
         */
        "voffset": number;
    }
    /**
     * Display a template preview experience. This will display the template's attached
     * documents with signing fields overlaid on each page. Fields will be color-coded
     * by recipient, and will be read-only (cannot be filled, moved, or altered).
     * ```ts
     * <verdocs-preview templateId={templateId} />
     * ```
     */
    interface VerdocsPreview {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The ID of the template to create the document from.
         */
        "templateId": string | null;
    }
    /**
     * Display a simple progress bar in a style consistent with the design system.
     * ```ts
     * <verdocs-progress-bar label="Uploading..." showPercent={true} percent={54} />
     * ```
     */
    interface VerdocsProgressBar {
        /**
          * Optional label to display above the bar
         */
        "label": string;
        /**
          * The current progress value (0-100)
         */
        "percent": number;
        /**
          * If true, the progress percentage will be displayed above the bar.
         */
        "showPercent": boolean;
    }
    /**
     * Display a drop-down menu of quick filter options.
     * ```ts
     * <verdocs-quick-filter options={[...options]} value={1} label="Filter" placeholder="All" />
     * ```
     */
    interface VerdocsQuickFilter {
        "label": string;
        /**
          * The menu options to display.
         */
        "options": IFilterOption[];
        "placeholder": string;
        "value": string;
    }
    /**
     * Display quick-function buttons for creating templates and documents.
     * Authentication is required to demonstrate this Element. You may do this in Storybook by using the Auth
     * embed. This Element will reuse the same session produced by logging in via that Embed.
     */
    interface VerdocsQuickFunctions {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
    }
    /**
     * Displays a radio button. Note that this is different from the `verdocs-field-radio-button` component, which is
     * designed to be used in signing experiences and contains settings that connect to template fields. This is just a
     * simple radio button for UI displays e.g. dialog boxes.
     * This control encapsulates a standard HTML radio button. To subscribe to change events, connect an `onChange`
     * handler. Sample usage:
     * ```ts
     * <verdocs-radio-button
     *    value="val1"
     *    name="someProperty"
     *    checked={this.someProperty === 'val1'}
     *    onInput={(e: any) => { this.someProperty = 'val1' }}
     *    disabled={false}
     * />
     * ```
     */
    interface VerdocsRadioButton {
        /**
          * Whether the radio button is currently selected.
         */
        "checked": boolean;
        /**
          * If set, the button will still be displayed but not selectable.
         */
        "disabled"?: boolean;
        /**
          * HTML form field name for the input.
         */
        "name": string;
        /**
          * Value to track with the input.
         */
        "value": string;
    }
    interface VerdocsSearch {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
    }
    /**
     * Displays a customizable input box for search queries.
     * Authentication is required to demonstrate this Element. You may do this in Storybook by using the Auth
     * embed. This Element will reuse the same session produced by logging in via that Embed.
     */
    interface VerdocsSearchBox {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        "focusField": () => Promise<void>;
        /**
          * If set, the input field will attempt to "grab" focus after being rendered.
         */
        "grabsFocus": boolean;
        /**
          * The placeholder to display in the input field.
         */
        "placeholder": string;
        /**
          * The text search string entered by the user.
         */
        "query": string;
        /**
          * If set to a value other than 'all', a removeable filter indicator will be displayed.
         */
        "type": TContentType;
    }
    interface VerdocsSearchTabs {
    }
    /**
     * Display a text input field. This is just a standard HTML input field with minimal markup to fit the
     * visual styles of the other components. Note that events "bubble" from the input field to the container,
     * so you can subscribe to the same DOM events (input, blur, etc) that a normal input would emit.
     * ```ts
     * <verdocs-select-input label="Select:" label="Select" options={[...options]}
     * @input ={() => {}} />
     * ```
     */
    interface VerdocsSelectInput {
        /**
          * Should the field be disabled?
         */
        "disabled": boolean;
        /**
          * The label for the field.
         */
        "label": string;
        /**
          * The options to list.
         */
        "options": {label: string; value: string}[];
        /**
          * The initial value for the input field.
         */
        "value": string;
    }
    /**
     * Display a form to send a template to one or more recipients in an envelope for signing. Note
     * that because most applications have custom workflow requirements to trigger after sending an
     * Envelope, this component does not actually perform that operation. Parent applications should
     * listen for the `onSend` event, and can pass the contents of `event.detail` directly to the
     * `createEnvelope()` call in JS-SDK.
     * Host applications should ensure the template is "sendable" before displaying this component.
     * To be sendable, a template must have at least one document attached, at least one participant
     * defined, and at least one field assigned to every "signer" participant. This component will
     * hide itself if the template is not sendable.
     * ```ts
     * <verdocs-send templateId={templateId} />
     * ```
     */
    interface VerdocsSend {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The environment the control is being called from, e.g. 'web'. This has an impact on how certain operations such as email communications are handled to ensure users receive the correct URLs for their invitations. Setting this to unknown values may produce unexpected/incorrect behaviors. If environment is not known, do this set this property.
         */
        "environment": string;
        "reset": () => Promise<void>;
        /**
          * The ID of the template to create the document from.
         */
        "templateId": string | null;
    }
    /**
     * Display a template preview experience. This will display the template's attached
     * documents with signing fields overlaid on each page. Fields will be color-coded
     * by recipient, and will be read-only (cannot be filled, moved, or altered).
     * ```ts
     * <verdocs-settings />
     * ```
     */
    interface VerdocsSettings {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
    }
    /**
     * Displays a settings form that allows the user to manage their API keys.
     */
    interface VerdocsSettingsApiKeys {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
    }
    /**
     * Displays a settings form that allows the user to manage their Verdocs profile.
     */
    interface VerdocsSettingsMembers {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
    }
    /**
     * Displays a settings form that allows the user to manage their Verdocs profile.
     */
    interface VerdocsSettingsOrganization {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
    }
    /**
     * Displays a settings form that allows the user to manage their Verdocs profile.
     */
    interface VerdocsSettingsProfile {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
    }
    /**
     * Display an envelope signing experience. This will display the envelope's attached
     * documents with signing fields overlaid on each page.
     * The component will attempt to initiate a signing session and load the specified
     * envelope. If successful, the recipient's fields will be enabled and the user will
     * be able to sign the envelope's attached documents. If not, an `sdkError` will be
     * thrown and the component will be blank/empty. To provide the best user experience,
     * applications should capture and handle this error to provide the user with
     * instructions/options for next steps based on the application's design and workflow.
     * Unlike other components, this will always create its own endpoint to manage the
     * session session. This endpoint will be included in event callbacks for the
     * convenience of host applications that may wish to make server calls using the
     * signer's credentials once signing is complete (e.g. to obtain copies of
     * the signed attachments.)
     */
    interface VerdocsSign {
        /**
          * The ID of the envelope to sign.
         */
        "envelopeId": string | null;
        /**
          * If set, (recommended), the host application should create a <DIV> element with a unique ID. When this component renders, the header will be removed from its default location and placed in the target element. This allows the parent application to more easily control its placement and scroll effects (e.g. "fixed").  The movement of the header to the target container is not dynamic - it is performed only on the initial render. Host applications should not conditionally render this container. If the header's visibility must be externally controlled, use CSS display options to hide/show it instead.
         */
        "headerTargetId": string | null;
        /**
          * The invite code for the signer.
         */
        "inviteCode": string | null;
        /**
          * The ID of the role that will be signing e.g. 'Recipient 1'
         */
        "roleId": string | null;
    }
    /**
     * Display a dialog that allows the user to specify a signature image, either by using a signature-font-generated image
     * based on their full name, or by hand-drawing their signature with a mouse or tablet.
     */
    interface VerdocsSignatureDialog {
        /**
          * Initial signature text
         */
        "name": string;
    }
    /**
     * Display a small loading spinner.
     * ```ts
     * <verdocs-spinner />
     * ```
     */
    interface VerdocsSpinner {
        "mode": 'light' | 'dark';
        "size": number;
    }
    /**
     * Displays an icon and message describing a document's completion status. For convenience, the status may be passed in either
     * directly as a status field or the whole document object may be passed in.
     * If the document is provided, the status flag will indicate the document's overall status. This also makes the component clickable
     * to display a popup panel with per-recipient status data.
     * If the status is provided as a string it can be either a `TRecipientStatus` or `TDocumentStatus` value.
     */
    interface VerdocsStatusIndicator {
        /**
          * The document to display status for. Ignored if `status` is set directly.
         */
        "envelope"?: IEnvelope | IEnvelopeSummary;
        /**
          * The size (height) of the indicator. The small variant is suitable for use in densely populated components such as table rows.
         */
        "size": 'small' | 'normal';
        /**
          * The status to display.
         */
        "status"?: TEnvelopeStatus | TRecipientStatus | 'accepted';
        /**
          * The theme to use for diplay.
         */
        "theme"?: 'dark' | 'light';
    }
    /**
     * Display a simple table of data. Columns and data cells may have custom renderers defined to
     * support creating interactive table layouts.
     * ```ts
     * <verdocs-table columns={[...columns]} data={[...data]} />
     * ```
     */
    interface VerdocsTable {
        /**
          * The columns to display
         */
        "columns": IColumn[];
        /**
          * The rows to display
         */
        "data": any[];
    }
    /**
     * Display a simple row of selectable tabs. This is a controlled element.
     * The parent must adjust selectedTab as selection events are fired.
     * ```ts
     * <verdocs-tabs tabs={[...tabs]} />
     * ```
     */
    interface VerdocsTabs {
        /**
          * The index of the tab to show selected.
         */
        "selectedTab": number;
        /**
          * The tabs to display
         */
        "tabs": ITab[];
    }
    /**
     * Displays an edit form that allows the user to view, add, or remove a template's attachments.
     * Note that an active session and valid template ID must be supplied.
     */
    interface VerdocsTemplateAttachments {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The template ID to edit.
         */
        "templateId": string;
    }
    /**
     * Display a set of tabs for the template builder.
     */
    interface VerdocsTemplateBuildTabs {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The step in the creation process to display.
         */
        "step": TVerdocsBuildStep1;
        /**
          * The ID of the template to create the document from. Unlike most other components, this is an optional parameter here. If the template ID is known, `step` may also be specified to force displaying a specific step in the creation process. If it is not specified, `step` will be ignored and the create step will be shown.
         */
        "templateId": string | null;
    }
    /**
     * Displays a summary of a template
     */
    interface VerdocsTemplateCard {
        /**
          * The template for which the card will be rendered.
         */
        "template": ITemplate;
    }
    /**
     * Displays a file upload mechanism suitable for the first step of creating a template.
     * This is typically the first step in a template creation workflow.
     */
    interface VerdocsTemplateCreate {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
    }
    /**
     * Represents one document page. This is primarily a layout container used to coordinate positions of
     * page-related layers such as the page itself, signature fields, etc. It is not intended to be used
     * on its own as an individual component.
     */
    interface VerdocsTemplateDocumentPage {
        /**
          * Whether the fields should be disabled (Builder)
         */
        "disabled": boolean;
        /**
          * The ID of the document to display.
         */
        "documentId": string;
        /**
          * Whether the field are interactable (done/submitted disables this)
         */
        "done": boolean;
        /**
          * Whether the fields should be editable (Builder)
         */
        "editable": boolean;
        /**
          * The endpoint to load from.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The layers that will be rendered. The DOM structure will be a DIV container with one child DIV for each layer. The parent DIV will have a unique ID, and each child DIV will have that ID with the layer name appended, e.g. if `pages` was ['page', 'fields'] the structure will be:  ```     <div id="verdocs-document-page-ker2fr1p9">       <div id="verdocs-document-page-ker2fr1p9-page"></div>       <div id="verdocs-document-page-ker2fr1p9-fields"></div>     </div> ```
         */
        "layers": IPageLayer[];
        /**
          * The page number being rendered. (Reminder: page numbers are 1-based.)
         */
        "pageNumber": number;
        /**
          * The ID of the template the document is for.
         */
        "templateId": string;
        /**
          * The "virtual" height of the page canvas.  Defaults to 792 which at 72dpi is 11" tall. This is used to compute the aspect ratio of the final rendered element when scaling up/down.
         */
        "virtualHeight": number;
        /**
          * The "virtual" width of the page canvas. Defaults to 612 which at 72dpi is 8.5" wide. This is used to compute the aspect ratio of the final rendered element when scaling up/down.
         */
        "virtualWidth": number;
    }
    /**
     * Displays an edit form that allows the user to adjust a field's settings.
     */
    interface VerdocsTemplateFieldProperties {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The field to configure.
         */
        "fieldName": string;
        /**
          * If specified, the properties card will have a "back" side with the help text as its content.
         */
        "helpText"?: string;
        /**
          * The template ID to edit.
         */
        "templateId": string;
    }
    /**
     * Displays a builder experience for laying out fields in a template. Note that this experience requires a large display area to
     * present all of the required controls, so it is primarily intended to be used in desktop environments.
     */
    interface VerdocsTemplateFields {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The ID of the template to create the document from.
         */
        "templateId": string | null;
        /**
          * If set, (recommended), the host application should create a <DIV> element with a unique ID. When this component renders, the toolbar will be removed from its default location and placed in the target element. This allows the parent application to more easily control its placement and scroll effects.  The movement of the toolbar to the target container is not dynamic - it is performed only on the initial render. Host applications should not conditionally render this container. If the toolbar's visibility must be externally controlled, use CSS display options to hide/show it instead.
         */
        "toolbarTargetId": string | null;
    }
    /**
     * Displays an edit form that allows the user to rename a template. Note that an active session and valid template ID must be supplied.
     */
    interface VerdocsTemplateName {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The template ID to edit.
         */
        "templateId": string;
    }
    /**
     * Displays an edit form that allows the user to adjust a template's reminders.
     */
    interface VerdocsTemplateReminders {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The template ID to edit.
         */
        "templateId": string;
    }
    /**
     * Display an edit form that allows the user to adjust a role's setitngs.
     */
    interface VerdocsTemplateRoleProperties {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The role name to edit.
         */
        "roleName": string;
        /**
          * Whether the dialog is currently being displayed. This allows it to be added to the DOM before being displayed.
         */
        "sender": TTemplateSenderType;
        /**
          * The template ID to edit.
         */
        "templateId": string;
    }
    /**
     * Displays an edit form that allows the user to adjust a template's roles and workflow.
     */
    interface VerdocsTemplateRoles {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The template ID to edit.
         */
        "templateId": string;
    }
    /**
     * Display a dialog that allows a template sender to be selected.
     */
    interface VerdocsTemplateSender {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * Whether the dialog is currently being displayed. This allows it to be added to the DOM before being displayed.
         */
        "sender": TTemplateSenderType;
        /**
          * The template ID to edit.
         */
        "templateId": string;
    }
    /**
     * Displays a clickable star that allows users to mark frequently-used templates.
     */
    interface VerdocsTemplateStar {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The template to display the star for.
         */
        "template": ITemplate;
    }
    /**
     * Displays a message listing a template's tags.
     */
    interface VerdocsTemplateTags {
        /**
          * The tags to display
         */
        "tags": any[];
    }
    /**
     * Displays an edit form that allows the user to adjust a template's visibility.
     */
    interface VerdocsTemplateVisibility {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The template ID to edit.
         */
        "templateId": string;
    }
    /**
     * Displays a list of envelopes matching specified conditions.
     */
    interface VerdocsTemplatesList {
        /**
          * Override the If set, filter templates by the specified name.
         */
        "allowedActions": TAllowedTemplateAction[];
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * If set, filter templates by the specified name.
         */
        "name": string;
        /**
          * The number of rows to display per page.
         */
        "rowsPerPage": number;
        /**
          * The initial page number to select. Pagination is internally controlled but may be overriden by the host applicaiton.
         */
        "selectedPage": number;
        /**
          * The sharing settings to filter by.
         */
        "sharing"?: 'all' | 'personal' | 'shared' | 'public';
        /**
          * Whether or not pagination should be enabled.
         */
        "showPagination": boolean;
        /**
          * The sort order to display.
         */
        "sort": IGetTemplateSummarySortBy;
        /**
          * The starred settings to filter by.
         */
        "starred": 'all' | 'starred' | 'unstarred';
    }
    /**
     * Display a text input field. This is just a standard HTML input field with minimal markup to fit the
     * visual styles of the other components. Note that events "bubble" from the input field to the container,
     * so you can subscribe to the same DOM events (input, blur, etc) that a normal input would emit.
     * ```ts
     * <verdocs-text-input type="text" label="Name" placeholder="Enter your name..." value="" />
     * ```
     */
    interface VerdocsTextInput {
        /**
          * If desired, the autocomplete attribute to set.
         */
        "autocomplete": string;
        /**
          * If set, a clear button will be displayed.
         */
        "clearable": boolean;
        /**
          * If set, a copy-to-clipboard button will be displayed. NOTE: A field may not be both clearable and copyable. If both properties are set to true, copyable will be ignored.
         */
        "copyable": boolean;
        /**
          * Should the field be disabled?
         */
        "disabled": boolean;
        /**
          * If supplied, a help icon will be displayed to provide the user more information.
         */
        "helpText": string;
        /**
          * The label for the field.
         */
        "label": string;
        /**
          * The placeholder for the field.
         */
        "placeholder": string;
        /**
          * Should the field be required?
         */
        "required": boolean;
        /**
          * The type of field to render. Only text-type fields are allowed here for the current styling. Additional types (e.g. a date picker) will be supported by other controls in the future.
         */
        "type": 'text' | 'password' | 'email' | 'number' | 'search' | 'tel' | 'url';
        /**
          * The initial value for the input field.
         */
        "value": string;
    }
    /**
     * Displays a label and a set of buttons, also allowing a default selection of a button.
     * ```ts
     * <verdocs-toggle options={[...options]} theme="light"></verdocs-toggle>
     * ```
     */
    interface VerdocsToggle {
        /**
          * The tags to display
         */
        "options": IToggleIconButtons;
        /**
          * The "theme" to be used
         */
        "theme": 'light' | 'dark';
    }
    /**
     * Displays a single button that can be toggled on or off by clicking it.
     * ```ts
     * <verdocs-toggle-button icon={MessageIcon} size="normal" active={true} />
     * ```
     */
    interface VerdocsToggleButton {
        "active": boolean;
        /**
          * If set, should be an SVG object. This will be rendered as the button's visible element. If icon is supplied, label is ignored.
         */
        "icon"?: string | null;
        /**
          * If set, should be an SVG object. This will be rendered as the button's visible element. If icon is supplied, label is ignored.
         */
        "label"?: string | null;
        /**
          * How large the button should be. Small buttons are intended for dialog boxes and other smaller scale UI regions.
         */
        "size"?: 'small' | 'normal';
    }
    /**
     * Displays a simple help icon. Upon hover or focus, a tooltip will be displayed with help text.
     * ```ts
     * <verdocs-toolbar-icon text="Sample tooltip text" icon={CalendarIcon} />
     * ```
     */
    interface VerdocsToolbarIcon {
        /**
          * SVG icon to display
         */
        "icon": string;
        /**
          * Override the Popper "placement" setting
         */
        "placement": Placement;
        /**
          * Help text to display on hover/focus
         */
        "text": string;
    }
    /**
     * Display a file upload tool. Note that the file is not actually transmitted, so it may be used by
     * callers with a variety of workflows. Instead, data about the chosen file will be passed to the
     * caller via the onNext event handler.
     */
    interface VerdocsUploadDialog {
    }
    /**
     * Render the documents attached to an envelope in read-only (view) mode. All documents are displayed in order.
     */
    interface VerdocsView {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint": VerdocsEndpoint;
        /**
          * The envelope ID to render. Set ONE OF templateId or envelopeId. If both are set, envelopeId will be ignored.
         */
        "envelopeId": string;
        /**
          * If set, (recommended), the host application should create a <DIV> element with a unique ID. When this component renders, the header will be removed from its default location and placed in the target element. This allows the parent application to more easily control its placement and scroll effects (e.g. "fixed").  The movement of the header to the target container is not dynamic - it is performed only on the initial render. Host applications should not conditionally render this container. If the header's visibility must be externally controlled, use CSS display options to hide/show it instead.
         */
        "headerTargetId": string | null;
    }
}
export interface VerdocsActivityBoxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsActivityBoxElement;
}
export interface VerdocsAuthCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsAuthElement;
}
export interface VerdocsBuildCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsBuildElement;
}
export interface VerdocsContactPickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsContactPickerElement;
}
export interface VerdocsDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsDialogElement;
}
export interface VerdocsDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsDropdownElement;
}
export interface VerdocsEnvelopeDocumentPageCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsEnvelopeDocumentPageElement;
}
export interface VerdocsEnvelopeRecipientLinkCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsEnvelopeRecipientLinkElement;
}
export interface VerdocsEnvelopeRecipientSummaryCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsEnvelopeRecipientSummaryElement;
}
export interface VerdocsEnvelopeSidebarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsEnvelopeSidebarElement;
}
export interface VerdocsEnvelopesListCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsEnvelopesListElement;
}
export interface VerdocsFieldAttachmentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsFieldAttachmentElement;
}
export interface VerdocsFieldCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsFieldCheckboxElement;
}
export interface VerdocsFieldDateCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsFieldDateElement;
}
export interface VerdocsFieldDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsFieldDropdownElement;
}
export interface VerdocsFieldInitialCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsFieldInitialElement;
}
export interface VerdocsFieldPaymentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsFieldPaymentElement;
}
export interface VerdocsFieldRadioButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsFieldRadioButtonElement;
}
export interface VerdocsFieldSignatureCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsFieldSignatureElement;
}
export interface VerdocsFieldTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsFieldTextareaElement;
}
export interface VerdocsFieldTextboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsFieldTextboxElement;
}
export interface VerdocsFieldTimestampCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsFieldTimestampElement;
}
export interface VerdocsFileChooserCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsFileChooserElement;
}
export interface VerdocsInitialDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsInitialDialogElement;
}
export interface VerdocsKbaDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsKbaDialogElement;
}
export interface VerdocsOkDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsOkDialogElement;
}
export interface VerdocsPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsPaginationElement;
}
export interface VerdocsPortalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsPortalElement;
}
export interface VerdocsPreviewCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsPreviewElement;
}
export interface VerdocsQuickFilterCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsQuickFilterElement;
}
export interface VerdocsQuickFunctionsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsQuickFunctionsElement;
}
export interface VerdocsSearchBoxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsSearchBoxElement;
}
export interface VerdocsSendCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsSendElement;
}
export interface VerdocsSettingsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsSettingsElement;
}
export interface VerdocsSettingsApiKeysCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsSettingsApiKeysElement;
}
export interface VerdocsSettingsMembersCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsSettingsMembersElement;
}
export interface VerdocsSettingsOrganizationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsSettingsOrganizationElement;
}
export interface VerdocsSettingsProfileCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsSettingsProfileElement;
}
export interface VerdocsSignCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsSignElement;
}
export interface VerdocsSignatureDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsSignatureDialogElement;
}
export interface VerdocsTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTableElement;
}
export interface VerdocsTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTabsElement;
}
export interface VerdocsTemplateAttachmentsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateAttachmentsElement;
}
export interface VerdocsTemplateBuildTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateBuildTabsElement;
}
export interface VerdocsTemplateCreateCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateCreateElement;
}
export interface VerdocsTemplateDocumentPageCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateDocumentPageElement;
}
export interface VerdocsTemplateFieldPropertiesCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateFieldPropertiesElement;
}
export interface VerdocsTemplateFieldsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateFieldsElement;
}
export interface VerdocsTemplateNameCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateNameElement;
}
export interface VerdocsTemplateRemindersCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateRemindersElement;
}
export interface VerdocsTemplateRolePropertiesCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateRolePropertiesElement;
}
export interface VerdocsTemplateRolesCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateRolesElement;
}
export interface VerdocsTemplateSenderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateSenderElement;
}
export interface VerdocsTemplateStarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateStarElement;
}
export interface VerdocsTemplateVisibilityCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplateVisibilityElement;
}
export interface VerdocsTemplatesListCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsTemplatesListElement;
}
export interface VerdocsToggleButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsToggleButtonElement;
}
export interface VerdocsUploadDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsUploadDialogElement;
}
export interface VerdocsViewCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVerdocsViewElement;
}
declare global {
    interface HTMLVerdocsActivityBoxElementEventMap {
        "sdkError": SDKError;
        "viewEnvelope": {endpoint: VerdocsEndpoint; entry: IActivityEntry};
        "viewAll": {endpoint: VerdocsEndpoint; view: string};
    }
    /**
     * Displays a box showing summaries of envelopes matching specified conditions. Activity Boxes show a fixed number
     * of items because they are meant to be laid out horizontally (if the user's screen is large enough) and this helps
     * them appear more visually balanced.
     */
    interface HTMLVerdocsActivityBoxElement extends Components.VerdocsActivityBox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsActivityBoxElementEventMap>(type: K, listener: (this: HTMLVerdocsActivityBoxElement, ev: VerdocsActivityBoxCustomEvent<HTMLVerdocsActivityBoxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsActivityBoxElementEventMap>(type: K, listener: (this: HTMLVerdocsActivityBoxElement, ev: VerdocsActivityBoxCustomEvent<HTMLVerdocsActivityBoxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsActivityBoxElement: {
        prototype: HTMLVerdocsActivityBoxElement;
        new (): HTMLVerdocsActivityBoxElement;
    };
    interface HTMLVerdocsAuthElementEventMap {
        "authenticated": IAuthStatus;
        "sdkError": SDKError;
    }
    /**
     * Display an authentication dialog that allows the user to login or sign up. If the user is already authenticated
     * with a valid session, this component will hide itself and fire the success callback immediately. It is up to the
     * host application to render the next appropriate view for the application.
     * To simplify UI development, a visibility flag can force this component to never display. This
     * allows you to susbcribe to notifications from client apps without calling the lower-level JS SDK.
     * This embed is responsive / mobile-friendly, but the calling application should provide at least a 300px wide
     * container to allow sufficient space for the required forms.
     * ```ts
     * <verdocs-auth onAuthenticated={e => console.log('Authentication state:', e.detail)} />
     * ```
     */
    interface HTMLVerdocsAuthElement extends Components.VerdocsAuth, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsAuthElementEventMap>(type: K, listener: (this: HTMLVerdocsAuthElement, ev: VerdocsAuthCustomEvent<HTMLVerdocsAuthElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsAuthElementEventMap>(type: K, listener: (this: HTMLVerdocsAuthElement, ev: VerdocsAuthCustomEvent<HTMLVerdocsAuthElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsAuthElement: {
        prototype: HTMLVerdocsAuthElement;
        new (): HTMLVerdocsAuthElement;
    };
    interface HTMLVerdocsBuildElementEventMap {
        "sdkError": SDKError;
        "stepChanged": TVerdocsBuildStep;
        "send": {roles: ICreateEnvelopeRole[]; name: string; template_id: string};
        "templateUpdated": {endpoint: VerdocsEndpoint; template: ITemplate; event: string};
        "templateCreated": {endpoint: VerdocsEndpoint; template: ITemplate; event: string};
        "rolesUpdated": {endpoint: VerdocsEndpoint; templateId: string; event: 'added' | 'deleted' | 'updated'; roles: IRole[]};
    }
    /**
     * Display a template building experience.
     * ```ts
     * <verdocs-build templateId={templateId} />
     * ```
     */
    interface HTMLVerdocsBuildElement extends Components.VerdocsBuild, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsBuildElementEventMap>(type: K, listener: (this: HTMLVerdocsBuildElement, ev: VerdocsBuildCustomEvent<HTMLVerdocsBuildElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsBuildElementEventMap>(type: K, listener: (this: HTMLVerdocsBuildElement, ev: VerdocsBuildCustomEvent<HTMLVerdocsBuildElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsBuildElement: {
        prototype: HTMLVerdocsBuildElement;
        new (): HTMLVerdocsBuildElement;
    };
    /**
     * A simple button, with consistent styling to other controls in the design system.
     * ```ts
     * <verdocs-button label="Click Me" size="normal" variant="standard" />
     * ```
     */
    interface HTMLVerdocsButtonElement extends Components.VerdocsButton, HTMLStencilElement {
    }
    var HTMLVerdocsButtonElement: {
        prototype: HTMLVerdocsButtonElement;
        new (): HTMLVerdocsButtonElement;
    };
    /**
     * Display an icon button that triggers a drop-down panel that can display
     * arbitrary child content, such as metadata, forms, or other controls.
     * ```ts
     *   <verdocs-button-panel .icon=${icon}>
     *     <h6>Field Settings</h6>
     *     <form>
     *     <p>
     *       <label>Field Name</label>
     *       <input type="text" placeholder="Field Name..." />
     *     </p>
     *     </form>
     *   </verdocs-button-panel>
     * ```
     */
    interface HTMLVerdocsButtonPanelElement extends Components.VerdocsButtonPanel, HTMLStencilElement {
    }
    var HTMLVerdocsButtonPanelElement: {
        prototype: HTMLVerdocsButtonPanelElement;
        new (): HTMLVerdocsButtonPanelElement;
    };
    /**
     * Displays a check box. Note that this is different from the `verdocs-field-checkbox` component, which is designed
     * to be used in signing experiences and contains settings that connect to template fields. This is just a simple check
     * box for UI displays e.g. dialog boxes.
     * This control encapsulates a standard HTML checkbox. To subscribe to change events, connect an `onChange`
     * handler. Sample usage:
     * ```ts
     * <verdocs-checkbox
     *    value="on"
     *    name="thingEnabled"
     *    checked={this.thingEnabled}
     *    onInput={(e: any) => (this.thingEnabled = e.target.checked)}
     * />
     * ```
     */
    interface HTMLVerdocsCheckboxElement extends Components.VerdocsCheckbox, HTMLStencilElement {
    }
    var HTMLVerdocsCheckboxElement: {
        prototype: HTMLVerdocsCheckboxElement;
        new (): HTMLVerdocsCheckboxElement;
    };
    /**
     * Render a simple error message.
     */
    interface HTMLVerdocsComponentErrorElement extends Components.VerdocsComponentError, HTMLStencilElement {
    }
    var HTMLVerdocsComponentErrorElement: {
        prototype: HTMLVerdocsComponentErrorElement;
        new (): HTMLVerdocsComponentErrorElement;
    };
    interface HTMLVerdocsContactPickerElementEventMap {
        "searchContacts": IContactSearchEvent;
        "exit": any;
        "next": IContactSelectEvent;
    }
    /**
     * Displays a contact picker suitable for filling out Recipient objects when sending Documents.
     * This picker can also be integrated with a backend to provide contact list / suggestion / address-book style behavior. As the
     * user interacts with the component, the text entered in the name field is sent back to the parent via the `searchContacts` event.
     * The parent can use that text as a query string to call a backend to obtain appropriate contacts to show. This list may also be
     * hard-coded ahead of time to provide the user with smart suggestions on initial display, such as "Recently Used" contacts, or
     * to always display the user's own contact record.
     */
    interface HTMLVerdocsContactPickerElement extends Components.VerdocsContactPicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsContactPickerElementEventMap>(type: K, listener: (this: HTMLVerdocsContactPickerElement, ev: VerdocsContactPickerCustomEvent<HTMLVerdocsContactPickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsContactPickerElementEventMap>(type: K, listener: (this: HTMLVerdocsContactPickerElement, ev: VerdocsContactPickerCustomEvent<HTMLVerdocsContactPickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsContactPickerElement: {
        prototype: HTMLVerdocsContactPickerElement;
        new (): HTMLVerdocsContactPickerElement;
    };
    interface HTMLVerdocsDialogElementEventMap {
        "exit": any;
    }
    /**
     * Display a simple dialog where the contents are provided via slots.
     */
    interface HTMLVerdocsDialogElement extends Components.VerdocsDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsDialogElementEventMap>(type: K, listener: (this: HTMLVerdocsDialogElement, ev: VerdocsDialogCustomEvent<HTMLVerdocsDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsDialogElementEventMap>(type: K, listener: (this: HTMLVerdocsDialogElement, ev: VerdocsDialogCustomEvent<HTMLVerdocsDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsDialogElement: {
        prototype: HTMLVerdocsDialogElement;
        new (): HTMLVerdocsDialogElement;
    };
    interface HTMLVerdocsDropdownElementEventMap {
        "optionSelected": IMenuOption;
    }
    /**
     * Display a drop-down menu button. A menu of the specified options will be displayed when the button is pressed. The menu will be hidden
     * when the button is pressed again, or an option is selected. Separators may be created by supplying an entry with an empty label.
     * ```ts
     * <verdocs-dropdown
     *   options={[
     *     {label: 'Option 1', disabled: true},
     *     {label: 'Option 2', id: '2'}
     *     {label: ''}
     *     {label: 'Option 3', id: '2'}
     *    ]}
     *   label="OK" onClick={() => (console.log('OK clicked'))}
     * />
     * ```
     */
    interface HTMLVerdocsDropdownElement extends Components.VerdocsDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsDropdownElementEventMap>(type: K, listener: (this: HTMLVerdocsDropdownElement, ev: VerdocsDropdownCustomEvent<HTMLVerdocsDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsDropdownElementEventMap>(type: K, listener: (this: HTMLVerdocsDropdownElement, ev: VerdocsDropdownCustomEvent<HTMLVerdocsDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsDropdownElement: {
        prototype: HTMLVerdocsDropdownElement;
        new (): HTMLVerdocsDropdownElement;
    };
    interface HTMLVerdocsEnvelopeDocumentPageElementEventMap {
        "pageRendered": IDocumentPageInfo;
    }
    /**
     * Represents one document page. This is primarily a layout container used to coordinate positions of
     * page-related layers such as the page itself, signature fields, etc. It is not intended to be used
     * on its own as an individual component.
     */
    interface HTMLVerdocsEnvelopeDocumentPageElement extends Components.VerdocsEnvelopeDocumentPage, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsEnvelopeDocumentPageElementEventMap>(type: K, listener: (this: HTMLVerdocsEnvelopeDocumentPageElement, ev: VerdocsEnvelopeDocumentPageCustomEvent<HTMLVerdocsEnvelopeDocumentPageElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsEnvelopeDocumentPageElementEventMap>(type: K, listener: (this: HTMLVerdocsEnvelopeDocumentPageElement, ev: VerdocsEnvelopeDocumentPageCustomEvent<HTMLVerdocsEnvelopeDocumentPageElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsEnvelopeDocumentPageElement: {
        prototype: HTMLVerdocsEnvelopeDocumentPageElement;
        new (): HTMLVerdocsEnvelopeDocumentPageElement;
    };
    interface HTMLVerdocsEnvelopeRecipientLinkElementEventMap {
        "next": {envelope: IEnvelope};
        "sdkError": SDKError;
    }
    /**
     * Displays a single recipient from an envelope, with the opportunity to copy an in-person
     * signing link for that recipient to use.
     */
    interface HTMLVerdocsEnvelopeRecipientLinkElement extends Components.VerdocsEnvelopeRecipientLink, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsEnvelopeRecipientLinkElementEventMap>(type: K, listener: (this: HTMLVerdocsEnvelopeRecipientLinkElement, ev: VerdocsEnvelopeRecipientLinkCustomEvent<HTMLVerdocsEnvelopeRecipientLinkElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsEnvelopeRecipientLinkElementEventMap>(type: K, listener: (this: HTMLVerdocsEnvelopeRecipientLinkElement, ev: VerdocsEnvelopeRecipientLinkCustomEvent<HTMLVerdocsEnvelopeRecipientLinkElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsEnvelopeRecipientLinkElement: {
        prototype: HTMLVerdocsEnvelopeRecipientLinkElement;
        new (): HTMLVerdocsEnvelopeRecipientLinkElement;
    };
    interface HTMLVerdocsEnvelopeRecipientSummaryElementEventMap {
        "another": {envelope: IEnvelope};
        "view": {envelope: IEnvelope};
        "next": {envelope: IEnvelope};
        "sdkError": SDKError;
    }
    /**
     * Displays a list of recipients with options to get in-person signing links for each one.
     */
    interface HTMLVerdocsEnvelopeRecipientSummaryElement extends Components.VerdocsEnvelopeRecipientSummary, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsEnvelopeRecipientSummaryElementEventMap>(type: K, listener: (this: HTMLVerdocsEnvelopeRecipientSummaryElement, ev: VerdocsEnvelopeRecipientSummaryCustomEvent<HTMLVerdocsEnvelopeRecipientSummaryElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsEnvelopeRecipientSummaryElementEventMap>(type: K, listener: (this: HTMLVerdocsEnvelopeRecipientSummaryElement, ev: VerdocsEnvelopeRecipientSummaryCustomEvent<HTMLVerdocsEnvelopeRecipientSummaryElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsEnvelopeRecipientSummaryElement: {
        prototype: HTMLVerdocsEnvelopeRecipientSummaryElement;
        new (): HTMLVerdocsEnvelopeRecipientSummaryElement;
    };
    interface HTMLVerdocsEnvelopeSidebarElementEventMap {
        "sdkError": SDKError;
        "envelopeUpdated": {endpoint: VerdocsEndpoint; envelope: IEnvelope; event: string};
        "toggle": {open: boolean};
        "another": {envelope: IEnvelope};
    }
    /**
     * Displays a file upload mechanism suitable for the first step of creating a template.
     * This is typically the first step in a template creation workflow.
     */
    interface HTMLVerdocsEnvelopeSidebarElement extends Components.VerdocsEnvelopeSidebar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsEnvelopeSidebarElementEventMap>(type: K, listener: (this: HTMLVerdocsEnvelopeSidebarElement, ev: VerdocsEnvelopeSidebarCustomEvent<HTMLVerdocsEnvelopeSidebarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsEnvelopeSidebarElementEventMap>(type: K, listener: (this: HTMLVerdocsEnvelopeSidebarElement, ev: VerdocsEnvelopeSidebarCustomEvent<HTMLVerdocsEnvelopeSidebarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsEnvelopeSidebarElement: {
        prototype: HTMLVerdocsEnvelopeSidebarElement;
        new (): HTMLVerdocsEnvelopeSidebarElement;
    };
    interface HTMLVerdocsEnvelopesListElementEventMap {
        "changeView": 'all' | 'inbox' | 'sent' | 'completed' | 'action' | 'waiting';
        "changeStatus": TEnvelopeStatus | 'all';
        "changeSort": 'name' | 'created_at' | 'updated_at' | 'canceled_at' | 'status';
        "changeMatch": string;
        "sdkError": SDKError;
        "viewEnvelope": {endpoint: VerdocsEndpoint; envelope: IEnvelope};
        "finishEnvelope": {endpoint: VerdocsEndpoint; envelope: IEnvelope};
    }
    /**
     * Displays a list of envelopes matching specified conditions.
     */
    interface HTMLVerdocsEnvelopesListElement extends Components.VerdocsEnvelopesList, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsEnvelopesListElementEventMap>(type: K, listener: (this: HTMLVerdocsEnvelopesListElement, ev: VerdocsEnvelopesListCustomEvent<HTMLVerdocsEnvelopesListElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsEnvelopesListElementEventMap>(type: K, listener: (this: HTMLVerdocsEnvelopesListElement, ev: VerdocsEnvelopesListCustomEvent<HTMLVerdocsEnvelopesListElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsEnvelopesListElement: {
        prototype: HTMLVerdocsEnvelopesListElement;
        new (): HTMLVerdocsEnvelopesListElement;
    };
    interface HTMLVerdocsFieldAttachmentElementEventMap {
        "settingsChanged": {fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField};
        "deleted": {fieldName: string};
        "attached": ISelectedFile;
    }
    /**
     * Displays an attachment field.
     */
    interface HTMLVerdocsFieldAttachmentElement extends Components.VerdocsFieldAttachment, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsFieldAttachmentElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldAttachmentElement, ev: VerdocsFieldAttachmentCustomEvent<HTMLVerdocsFieldAttachmentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsFieldAttachmentElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldAttachmentElement, ev: VerdocsFieldAttachmentCustomEvent<HTMLVerdocsFieldAttachmentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsFieldAttachmentElement: {
        prototype: HTMLVerdocsFieldAttachmentElement;
        new (): HTMLVerdocsFieldAttachmentElement;
    };
    interface HTMLVerdocsFieldCheckboxElementEventMap {
        "settingsChanged": {fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField};
        "deleted": {fieldName: string};
    }
    /**
     * Displays a checkbox.
     */
    interface HTMLVerdocsFieldCheckboxElement extends Components.VerdocsFieldCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsFieldCheckboxElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldCheckboxElement, ev: VerdocsFieldCheckboxCustomEvent<HTMLVerdocsFieldCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsFieldCheckboxElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldCheckboxElement, ev: VerdocsFieldCheckboxCustomEvent<HTMLVerdocsFieldCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsFieldCheckboxElement: {
        prototype: HTMLVerdocsFieldCheckboxElement;
        new (): HTMLVerdocsFieldCheckboxElement;
    };
    interface HTMLVerdocsFieldDateElementEventMap {
        "settingsPress": any;
        "settingsChanged": {fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField};
        "deleted": {fieldName: string};
    }
    /**
     * Displays a date field. When tapped or clicked, the input element will display a date picker component.
     */
    interface HTMLVerdocsFieldDateElement extends Components.VerdocsFieldDate, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsFieldDateElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldDateElement, ev: VerdocsFieldDateCustomEvent<HTMLVerdocsFieldDateElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsFieldDateElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldDateElement, ev: VerdocsFieldDateCustomEvent<HTMLVerdocsFieldDateElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsFieldDateElement: {
        prototype: HTMLVerdocsFieldDateElement;
        new (): HTMLVerdocsFieldDateElement;
    };
    interface HTMLVerdocsFieldDropdownElementEventMap {
        "fieldChange": string;
        "settingsChanged": {fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField};
        "deleted": {fieldName: string};
    }
    /**
     * Displays a dropdown field that allows the user to choose one of a list of options.
     */
    interface HTMLVerdocsFieldDropdownElement extends Components.VerdocsFieldDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsFieldDropdownElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldDropdownElement, ev: VerdocsFieldDropdownCustomEvent<HTMLVerdocsFieldDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsFieldDropdownElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldDropdownElement, ev: VerdocsFieldDropdownCustomEvent<HTMLVerdocsFieldDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsFieldDropdownElement: {
        prototype: HTMLVerdocsFieldDropdownElement;
        new (): HTMLVerdocsFieldDropdownElement;
    };
    interface HTMLVerdocsFieldInitialElementEventMap {
        "adopt": string;
        "exit": any;
        "fieldChange": string;
        "settingsChanged": {fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField};
        "settingsPress": any;
        "deleted": {fieldName: string};
    }
    /**
     * Displays an initial field. If an initial already exists, it will be displayed and the field
     * will be disabled. Otherwise, a placeholder button will be shown. Clicking the button will
     * show a dialog to adopt an initial.
     * NOTE: When initial fields are completed they will be filled with an initial "stamp".
     * This requires operation against a live, valid envelope. If you are testing this component
     * in Storybook, it will not be visible here.
     */
    interface HTMLVerdocsFieldInitialElement extends Components.VerdocsFieldInitial, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsFieldInitialElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldInitialElement, ev: VerdocsFieldInitialCustomEvent<HTMLVerdocsFieldInitialElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsFieldInitialElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldInitialElement, ev: VerdocsFieldInitialCustomEvent<HTMLVerdocsFieldInitialElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsFieldInitialElement: {
        prototype: HTMLVerdocsFieldInitialElement;
        new (): HTMLVerdocsFieldInitialElement;
    };
    interface HTMLVerdocsFieldPaymentElementEventMap {
        "signatureComplete": string;
        "initialComplete": string;
        "settingsChanged": {fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField};
        "deleted": {fieldName: string};
    }
    /**
     * Displays a signature field. Various field types are supported, including traditional Signature and Initials types as well as
     * input types like text and checkbox.
     */
    interface HTMLVerdocsFieldPaymentElement extends Components.VerdocsFieldPayment, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsFieldPaymentElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldPaymentElement, ev: VerdocsFieldPaymentCustomEvent<HTMLVerdocsFieldPaymentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsFieldPaymentElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldPaymentElement, ev: VerdocsFieldPaymentCustomEvent<HTMLVerdocsFieldPaymentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsFieldPaymentElement: {
        prototype: HTMLVerdocsFieldPaymentElement;
        new (): HTMLVerdocsFieldPaymentElement;
    };
    interface HTMLVerdocsFieldRadioButtonElementEventMap {
        "settingsChanged": {fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField};
        "deleted": {fieldName: string};
    }
    /**
     * Displays a radio button.
     */
    interface HTMLVerdocsFieldRadioButtonElement extends Components.VerdocsFieldRadioButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsFieldRadioButtonElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldRadioButtonElement, ev: VerdocsFieldRadioButtonCustomEvent<HTMLVerdocsFieldRadioButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsFieldRadioButtonElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldRadioButtonElement, ev: VerdocsFieldRadioButtonCustomEvent<HTMLVerdocsFieldRadioButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsFieldRadioButtonElement: {
        prototype: HTMLVerdocsFieldRadioButtonElement;
        new (): HTMLVerdocsFieldRadioButtonElement;
    };
    interface HTMLVerdocsFieldSignatureElementEventMap {
        "fieldChange": string;
        "settingsPress": any;
        "settingsChanged": {fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField};
        "deleted": {fieldName: string};
    }
    /**
     * Displays a signature field. If a signature already exists, it will be displayed and the field
     * will be disabled. Otherwise, a placeholder button will be shown. Clicking the button will
     * show a dialog to adopt a signature.
     * NOTE: When signature fields are completed they will be filled with a signature "stamp".
     * This requires operation against a live, valid envelope. If you are testing this component
     * in Storybook, it will not be visible here.
     */
    interface HTMLVerdocsFieldSignatureElement extends Components.VerdocsFieldSignature, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsFieldSignatureElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldSignatureElement, ev: VerdocsFieldSignatureCustomEvent<HTMLVerdocsFieldSignatureElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsFieldSignatureElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldSignatureElement, ev: VerdocsFieldSignatureCustomEvent<HTMLVerdocsFieldSignatureElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsFieldSignatureElement: {
        prototype: HTMLVerdocsFieldSignatureElement;
        new (): HTMLVerdocsFieldSignatureElement;
    };
    interface HTMLVerdocsFieldTextareaElementEventMap {
        "settingsChanged": {fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField};
        "deleted": {fieldName: string};
    }
    /**
     * Display a multi-line text input field. Reminder: the "position" of the field is specified
     * as the BOTTOM-LEFT corner.
     */
    interface HTMLVerdocsFieldTextareaElement extends Components.VerdocsFieldTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsFieldTextareaElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldTextareaElement, ev: VerdocsFieldTextareaCustomEvent<HTMLVerdocsFieldTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsFieldTextareaElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldTextareaElement, ev: VerdocsFieldTextareaCustomEvent<HTMLVerdocsFieldTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsFieldTextareaElement: {
        prototype: HTMLVerdocsFieldTextareaElement;
        new (): HTMLVerdocsFieldTextareaElement;
    };
    interface HTMLVerdocsFieldTextboxElementEventMap {
        "settingsChanged": {fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField};
        "deleted": {fieldName: string};
    }
    /**
     * Display a simple 1-line text input field.
     */
    interface HTMLVerdocsFieldTextboxElement extends Components.VerdocsFieldTextbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsFieldTextboxElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldTextboxElement, ev: VerdocsFieldTextboxCustomEvent<HTMLVerdocsFieldTextboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsFieldTextboxElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldTextboxElement, ev: VerdocsFieldTextboxCustomEvent<HTMLVerdocsFieldTextboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsFieldTextboxElement: {
        prototype: HTMLVerdocsFieldTextboxElement;
        new (): HTMLVerdocsFieldTextboxElement;
    };
    interface HTMLVerdocsFieldTimestampElementEventMap {
        "settingsChanged": {fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField};
        "deleted": {fieldName: string};
    }
    /**
     * Display a timestamp. Timestamps are not editable by signers. Instead, they are automatically
     * filled when the signer submits the document.
     */
    interface HTMLVerdocsFieldTimestampElement extends Components.VerdocsFieldTimestamp, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsFieldTimestampElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldTimestampElement, ev: VerdocsFieldTimestampCustomEvent<HTMLVerdocsFieldTimestampElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsFieldTimestampElementEventMap>(type: K, listener: (this: HTMLVerdocsFieldTimestampElement, ev: VerdocsFieldTimestampCustomEvent<HTMLVerdocsFieldTimestampElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsFieldTimestampElement: {
        prototype: HTMLVerdocsFieldTimestampElement;
        new (): HTMLVerdocsFieldTimestampElement;
    };
    interface HTMLVerdocsFileChooserElementEventMap {
        "fileSelected": {file: File | null};
    }
    /**
     * Displays a file picker to upload an attachment. This component is just the picker - the host application or component should
     * provide the actual upload functionality.
     * ```ts
     * <verdocs-file-chooser onFileSelected={(e) => console.log('File Selected', e.detail)} />
     * ```
     */
    interface HTMLVerdocsFileChooserElement extends Components.VerdocsFileChooser, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsFileChooserElementEventMap>(type: K, listener: (this: HTMLVerdocsFileChooserElement, ev: VerdocsFileChooserCustomEvent<HTMLVerdocsFileChooserElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsFileChooserElementEventMap>(type: K, listener: (this: HTMLVerdocsFileChooserElement, ev: VerdocsFileChooserCustomEvent<HTMLVerdocsFileChooserElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsFileChooserElement: {
        prototype: HTMLVerdocsFileChooserElement;
        new (): HTMLVerdocsFileChooserElement;
    };
    /**
     * Displays a simple help icon. Upon hover or focus, a tooltip will be displayed with help text.
     * ```ts
     * <verdocs-help-icon text="Sample help text" />
     * ```
     */
    interface HTMLVerdocsHelpIconElement extends Components.VerdocsHelpIcon, HTMLStencilElement {
    }
    var HTMLVerdocsHelpIconElement: {
        prototype: HTMLVerdocsHelpIconElement;
        new (): HTMLVerdocsHelpIconElement;
    };
    interface HTMLVerdocsInitialDialogElementEventMap {
        "next": string;
        "exit": any;
    }
    /**
     * Display a dialog that allows the user to specify an initials image, either by using a signature-font-generated image
     * based on their full name, or by hand-drawing their initials with a mouse or tablet.
     */
    interface HTMLVerdocsInitialDialogElement extends Components.VerdocsInitialDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsInitialDialogElementEventMap>(type: K, listener: (this: HTMLVerdocsInitialDialogElement, ev: VerdocsInitialDialogCustomEvent<HTMLVerdocsInitialDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsInitialDialogElementEventMap>(type: K, listener: (this: HTMLVerdocsInitialDialogElement, ev: VerdocsInitialDialogCustomEvent<HTMLVerdocsInitialDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsInitialDialogElement: {
        prototype: HTMLVerdocsInitialDialogElement;
        new (): HTMLVerdocsInitialDialogElement;
    };
    interface HTMLVerdocsKbaDialogElementEventMap {
        "exit": any;
        "next": string;
    }
    /**
     * Prompt the user to confirm their identity with a series of questions.
     */
    interface HTMLVerdocsKbaDialogElement extends Components.VerdocsKbaDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsKbaDialogElementEventMap>(type: K, listener: (this: HTMLVerdocsKbaDialogElement, ev: VerdocsKbaDialogCustomEvent<HTMLVerdocsKbaDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsKbaDialogElementEventMap>(type: K, listener: (this: HTMLVerdocsKbaDialogElement, ev: VerdocsKbaDialogCustomEvent<HTMLVerdocsKbaDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsKbaDialogElement: {
        prototype: HTMLVerdocsKbaDialogElement;
        new (): HTMLVerdocsKbaDialogElement;
    };
    /**
     * Animated loader placeholder. There are currently no configuration options for this control.
     * ```ts
     * <verdocs-loader />
     * ```
     */
    interface HTMLVerdocsLoaderElement extends Components.VerdocsLoader, HTMLStencilElement {
    }
    var HTMLVerdocsLoaderElement: {
        prototype: HTMLVerdocsLoaderElement;
        new (): HTMLVerdocsLoaderElement;
    };
    interface HTMLVerdocsOkDialogElementEventMap {
        "next": any;
        "exit": any;
    }
    /**
     * Display a simple text dialog box with an Ok button. This adds a partially-transparent overlay and screen-centered dialog
     * box with a message and optional header/title. An OK button is shown that will dismiss the message.
     * It can also be dismissed by clicking the background overlay.
     */
    interface HTMLVerdocsOkDialogElement extends Components.VerdocsOkDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsOkDialogElementEventMap>(type: K, listener: (this: HTMLVerdocsOkDialogElement, ev: VerdocsOkDialogCustomEvent<HTMLVerdocsOkDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsOkDialogElementEventMap>(type: K, listener: (this: HTMLVerdocsOkDialogElement, ev: VerdocsOkDialogCustomEvent<HTMLVerdocsOkDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsOkDialogElement: {
        prototype: HTMLVerdocsOkDialogElement;
        new (): HTMLVerdocsOkDialogElement;
    };
    /**
     * Display a small summary card describing an organization.
     * ```ts
     * <verdocs-organization-card organization={organization} />
     * ```
     */
    interface HTMLVerdocsOrganizationCardElement extends Components.VerdocsOrganizationCard, HTMLStencilElement {
    }
    var HTMLVerdocsOrganizationCardElement: {
        prototype: HTMLVerdocsOrganizationCardElement;
        new (): HTMLVerdocsOrganizationCardElement;
    };
    interface HTMLVerdocsPaginationElementEventMap {
        "selectPage": {selectedPage: number};
    }
    /**
     * Display a simple pagination control with individual buttons to move through the data set.
     * ```ts
     * <verdocs-pagination
     *   selectedPage={1}
     *   itemCount={50}
     *   perPage={10}
     *   onSelectPage={(e) => {setSelectedpage(e.detail.selectedPage)}}
     * />
     * ```
     */
    interface HTMLVerdocsPaginationElement extends Components.VerdocsPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsPaginationElementEventMap>(type: K, listener: (this: HTMLVerdocsPaginationElement, ev: VerdocsPaginationCustomEvent<HTMLVerdocsPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsPaginationElementEventMap>(type: K, listener: (this: HTMLVerdocsPaginationElement, ev: VerdocsPaginationCustomEvent<HTMLVerdocsPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsPaginationElement: {
        prototype: HTMLVerdocsPaginationElement;
        new (): HTMLVerdocsPaginationElement;
    };
    interface HTMLVerdocsPortalElementEventMap {
        "clickAway": void;
    }
    /**
     * Display a child component in a "portal", popping it out of the main DOM tree
     * to allow it to escape the bounds set by its parent.
     * @credit https://github.com/tomas-teston/stencil-portal for the basic
     * technique. This has been altered in a few ways to make it more friendly
     * to cases where there may be multiple portals on the page and provide more
     * alignment options for the child to be displayed.
     * ```ts
     * <div style="padding: 40px">
     * <div id="sample-tooltip" style="border: 1px solid green; padding: 3px 10px;">
     * Tooltip Anchor
     * <verdocs-portal anchor="sample-tooltip" .align=${align} .voffset=${voffset}>
     * <div style="border: 1px solid red; padding: 3px 10px;">Tooltip</div>
     * </verdocs-portal>
     * </div>
     * </div>
     * ```
     */
    interface HTMLVerdocsPortalElement extends Components.VerdocsPortal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsPortalElementEventMap>(type: K, listener: (this: HTMLVerdocsPortalElement, ev: VerdocsPortalCustomEvent<HTMLVerdocsPortalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsPortalElementEventMap>(type: K, listener: (this: HTMLVerdocsPortalElement, ev: VerdocsPortalCustomEvent<HTMLVerdocsPortalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsPortalElement: {
        prototype: HTMLVerdocsPortalElement;
        new (): HTMLVerdocsPortalElement;
    };
    interface HTMLVerdocsPreviewElementEventMap {
        "sdkError": SDKError;
    }
    /**
     * Display a template preview experience. This will display the template's attached
     * documents with signing fields overlaid on each page. Fields will be color-coded
     * by recipient, and will be read-only (cannot be filled, moved, or altered).
     * ```ts
     * <verdocs-preview templateId={templateId} />
     * ```
     */
    interface HTMLVerdocsPreviewElement extends Components.VerdocsPreview, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsPreviewElementEventMap>(type: K, listener: (this: HTMLVerdocsPreviewElement, ev: VerdocsPreviewCustomEvent<HTMLVerdocsPreviewElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsPreviewElementEventMap>(type: K, listener: (this: HTMLVerdocsPreviewElement, ev: VerdocsPreviewCustomEvent<HTMLVerdocsPreviewElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsPreviewElement: {
        prototype: HTMLVerdocsPreviewElement;
        new (): HTMLVerdocsPreviewElement;
    };
    /**
     * Display a simple progress bar in a style consistent with the design system.
     * ```ts
     * <verdocs-progress-bar label="Uploading..." showPercent={true} percent={54} />
     * ```
     */
    interface HTMLVerdocsProgressBarElement extends Components.VerdocsProgressBar, HTMLStencilElement {
    }
    var HTMLVerdocsProgressBarElement: {
        prototype: HTMLVerdocsProgressBarElement;
        new (): HTMLVerdocsProgressBarElement;
    };
    interface HTMLVerdocsQuickFilterElementEventMap {
        "optionSelected": IFilterOption;
    }
    /**
     * Display a drop-down menu of quick filter options.
     * ```ts
     * <verdocs-quick-filter options={[...options]} value={1} label="Filter" placeholder="All" />
     * ```
     */
    interface HTMLVerdocsQuickFilterElement extends Components.VerdocsQuickFilter, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsQuickFilterElementEventMap>(type: K, listener: (this: HTMLVerdocsQuickFilterElement, ev: VerdocsQuickFilterCustomEvent<HTMLVerdocsQuickFilterElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsQuickFilterElementEventMap>(type: K, listener: (this: HTMLVerdocsQuickFilterElement, ev: VerdocsQuickFilterCustomEvent<HTMLVerdocsQuickFilterElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsQuickFilterElement: {
        prototype: HTMLVerdocsQuickFilterElement;
        new (): HTMLVerdocsQuickFilterElement;
    };
    interface HTMLVerdocsQuickFunctionsElementEventMap {
        "createTemplate": any;
        "createDocument": any;
    }
    /**
     * Display quick-function buttons for creating templates and documents.
     * Authentication is required to demonstrate this Element. You may do this in Storybook by using the Auth
     * embed. This Element will reuse the same session produced by logging in via that Embed.
     */
    interface HTMLVerdocsQuickFunctionsElement extends Components.VerdocsQuickFunctions, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsQuickFunctionsElementEventMap>(type: K, listener: (this: HTMLVerdocsQuickFunctionsElement, ev: VerdocsQuickFunctionsCustomEvent<HTMLVerdocsQuickFunctionsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsQuickFunctionsElementEventMap>(type: K, listener: (this: HTMLVerdocsQuickFunctionsElement, ev: VerdocsQuickFunctionsCustomEvent<HTMLVerdocsQuickFunctionsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsQuickFunctionsElement: {
        prototype: HTMLVerdocsQuickFunctionsElement;
        new (): HTMLVerdocsQuickFunctionsElement;
    };
    /**
     * Displays a radio button. Note that this is different from the `verdocs-field-radio-button` component, which is
     * designed to be used in signing experiences and contains settings that connect to template fields. This is just a
     * simple radio button for UI displays e.g. dialog boxes.
     * This control encapsulates a standard HTML radio button. To subscribe to change events, connect an `onChange`
     * handler. Sample usage:
     * ```ts
     * <verdocs-radio-button
     *    value="val1"
     *    name="someProperty"
     *    checked={this.someProperty === 'val1'}
     *    onInput={(e: any) => { this.someProperty = 'val1' }}
     *    disabled={false}
     * />
     * ```
     */
    interface HTMLVerdocsRadioButtonElement extends Components.VerdocsRadioButton, HTMLStencilElement {
    }
    var HTMLVerdocsRadioButtonElement: {
        prototype: HTMLVerdocsRadioButtonElement;
        new (): HTMLVerdocsRadioButtonElement;
    };
    interface HTMLVerdocsSearchElement extends Components.VerdocsSearch, HTMLStencilElement {
    }
    var HTMLVerdocsSearchElement: {
        prototype: HTMLVerdocsSearchElement;
        new (): HTMLVerdocsSearchElement;
    };
    interface HTMLVerdocsSearchBoxElementEventMap {
        "searchClicked": ISearchEvent;
        "typeChanged": TContentType;
        "queryChanged": string;
    }
    /**
     * Displays a customizable input box for search queries.
     * Authentication is required to demonstrate this Element. You may do this in Storybook by using the Auth
     * embed. This Element will reuse the same session produced by logging in via that Embed.
     */
    interface HTMLVerdocsSearchBoxElement extends Components.VerdocsSearchBox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsSearchBoxElementEventMap>(type: K, listener: (this: HTMLVerdocsSearchBoxElement, ev: VerdocsSearchBoxCustomEvent<HTMLVerdocsSearchBoxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsSearchBoxElementEventMap>(type: K, listener: (this: HTMLVerdocsSearchBoxElement, ev: VerdocsSearchBoxCustomEvent<HTMLVerdocsSearchBoxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsSearchBoxElement: {
        prototype: HTMLVerdocsSearchBoxElement;
        new (): HTMLVerdocsSearchBoxElement;
    };
    interface HTMLVerdocsSearchTabsElement extends Components.VerdocsSearchTabs, HTMLStencilElement {
    }
    var HTMLVerdocsSearchTabsElement: {
        prototype: HTMLVerdocsSearchTabsElement;
        new (): HTMLVerdocsSearchTabsElement;
    };
    /**
     * Display a text input field. This is just a standard HTML input field with minimal markup to fit the
     * visual styles of the other components. Note that events "bubble" from the input field to the container,
     * so you can subscribe to the same DOM events (input, blur, etc) that a normal input would emit.
     * ```ts
     * <verdocs-select-input label="Select:" label="Select" options={[...options]}
     * @input ={() => {}} />
     * ```
     */
    interface HTMLVerdocsSelectInputElement extends Components.VerdocsSelectInput, HTMLStencilElement {
    }
    var HTMLVerdocsSelectInputElement: {
        prototype: HTMLVerdocsSelectInputElement;
        new (): HTMLVerdocsSelectInputElement;
    };
    interface HTMLVerdocsSendElementEventMap {
        "sendingEnvelope": {sending: boolean};
        "send": {roles: ICreateEnvelopeRole[]; name: string; template_id: string; envelope_id: string; envelope: IEnvelope};
        "exit": any;
        "sdkError": SDKError;
        "searchContacts": IContactSearchEvent1;
    }
    /**
     * Display a form to send a template to one or more recipients in an envelope for signing. Note
     * that because most applications have custom workflow requirements to trigger after sending an
     * Envelope, this component does not actually perform that operation. Parent applications should
     * listen for the `onSend` event, and can pass the contents of `event.detail` directly to the
     * `createEnvelope()` call in JS-SDK.
     * Host applications should ensure the template is "sendable" before displaying this component.
     * To be sendable, a template must have at least one document attached, at least one participant
     * defined, and at least one field assigned to every "signer" participant. This component will
     * hide itself if the template is not sendable.
     * ```ts
     * <verdocs-send templateId={templateId} />
     * ```
     */
    interface HTMLVerdocsSendElement extends Components.VerdocsSend, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsSendElementEventMap>(type: K, listener: (this: HTMLVerdocsSendElement, ev: VerdocsSendCustomEvent<HTMLVerdocsSendElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsSendElementEventMap>(type: K, listener: (this: HTMLVerdocsSendElement, ev: VerdocsSendCustomEvent<HTMLVerdocsSendElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsSendElement: {
        prototype: HTMLVerdocsSendElement;
        new (): HTMLVerdocsSendElement;
    };
    interface HTMLVerdocsSettingsElementEventMap {
        "sdkError": SDKError;
    }
    /**
     * Display a template preview experience. This will display the template's attached
     * documents with signing fields overlaid on each page. Fields will be color-coded
     * by recipient, and will be read-only (cannot be filled, moved, or altered).
     * ```ts
     * <verdocs-settings />
     * ```
     */
    interface HTMLVerdocsSettingsElement extends Components.VerdocsSettings, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsSettingsElementEventMap>(type: K, listener: (this: HTMLVerdocsSettingsElement, ev: VerdocsSettingsCustomEvent<HTMLVerdocsSettingsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsSettingsElementEventMap>(type: K, listener: (this: HTMLVerdocsSettingsElement, ev: VerdocsSettingsCustomEvent<HTMLVerdocsSettingsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsSettingsElement: {
        prototype: HTMLVerdocsSettingsElement;
        new (): HTMLVerdocsSettingsElement;
    };
    interface HTMLVerdocsSettingsApiKeysElementEventMap {
        "sdkError": SDKError;
        "memberInvited": {endpoint: VerdocsEndpoint; member: IProfile};
        "memberUpdated": {endpoint: VerdocsEndpoint; member: IProfile};
        "memberRemoved": {endpoint: VerdocsEndpoint; member: IProfile};
    }
    /**
     * Displays a settings form that allows the user to manage their API keys.
     */
    interface HTMLVerdocsSettingsApiKeysElement extends Components.VerdocsSettingsApiKeys, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsSettingsApiKeysElementEventMap>(type: K, listener: (this: HTMLVerdocsSettingsApiKeysElement, ev: VerdocsSettingsApiKeysCustomEvent<HTMLVerdocsSettingsApiKeysElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsSettingsApiKeysElementEventMap>(type: K, listener: (this: HTMLVerdocsSettingsApiKeysElement, ev: VerdocsSettingsApiKeysCustomEvent<HTMLVerdocsSettingsApiKeysElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsSettingsApiKeysElement: {
        prototype: HTMLVerdocsSettingsApiKeysElement;
        new (): HTMLVerdocsSettingsApiKeysElement;
    };
    interface HTMLVerdocsSettingsMembersElementEventMap {
        "sdkError": SDKError;
        "memberInvited": {endpoint: VerdocsEndpoint; member: IProfile};
        "memberUpdated": {endpoint: VerdocsEndpoint; member: IProfile};
        "memberRemoved": {endpoint: VerdocsEndpoint; member: IProfile};
    }
    /**
     * Displays a settings form that allows the user to manage their Verdocs profile.
     */
    interface HTMLVerdocsSettingsMembersElement extends Components.VerdocsSettingsMembers, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsSettingsMembersElementEventMap>(type: K, listener: (this: HTMLVerdocsSettingsMembersElement, ev: VerdocsSettingsMembersCustomEvent<HTMLVerdocsSettingsMembersElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsSettingsMembersElementEventMap>(type: K, listener: (this: HTMLVerdocsSettingsMembersElement, ev: VerdocsSettingsMembersCustomEvent<HTMLVerdocsSettingsMembersElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsSettingsMembersElement: {
        prototype: HTMLVerdocsSettingsMembersElement;
        new (): HTMLVerdocsSettingsMembersElement;
    };
    interface HTMLVerdocsSettingsOrganizationElementEventMap {
        "sdkError": SDKError;
        "organizationUpdated": {endpoint: VerdocsEndpoint; organization: IOrganization};
    }
    /**
     * Displays a settings form that allows the user to manage their Verdocs profile.
     */
    interface HTMLVerdocsSettingsOrganizationElement extends Components.VerdocsSettingsOrganization, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsSettingsOrganizationElementEventMap>(type: K, listener: (this: HTMLVerdocsSettingsOrganizationElement, ev: VerdocsSettingsOrganizationCustomEvent<HTMLVerdocsSettingsOrganizationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsSettingsOrganizationElementEventMap>(type: K, listener: (this: HTMLVerdocsSettingsOrganizationElement, ev: VerdocsSettingsOrganizationCustomEvent<HTMLVerdocsSettingsOrganizationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsSettingsOrganizationElement: {
        prototype: HTMLVerdocsSettingsOrganizationElement;
        new (): HTMLVerdocsSettingsOrganizationElement;
    };
    interface HTMLVerdocsSettingsProfileElementEventMap {
        "sdkError": SDKError;
        "profileUpdated": {endpoint: VerdocsEndpoint; profile: IProfile};
    }
    /**
     * Displays a settings form that allows the user to manage their Verdocs profile.
     */
    interface HTMLVerdocsSettingsProfileElement extends Components.VerdocsSettingsProfile, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsSettingsProfileElementEventMap>(type: K, listener: (this: HTMLVerdocsSettingsProfileElement, ev: VerdocsSettingsProfileCustomEvent<HTMLVerdocsSettingsProfileElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsSettingsProfileElementEventMap>(type: K, listener: (this: HTMLVerdocsSettingsProfileElement, ev: VerdocsSettingsProfileCustomEvent<HTMLVerdocsSettingsProfileElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsSettingsProfileElement: {
        prototype: HTMLVerdocsSettingsProfileElement;
        new (): HTMLVerdocsSettingsProfileElement;
    };
    interface HTMLVerdocsSignElementEventMap {
        "sdkError": SDKError;
        "envelopeLoaded": {endpoint: VerdocsEndpoint; envelope: IEnvelope};
        "envelopeUpdated": {endpoint: VerdocsEndpoint; envelope: IEnvelope; event: string};
    }
    /**
     * Display an envelope signing experience. This will display the envelope's attached
     * documents with signing fields overlaid on each page.
     * The component will attempt to initiate a signing session and load the specified
     * envelope. If successful, the recipient's fields will be enabled and the user will
     * be able to sign the envelope's attached documents. If not, an `sdkError` will be
     * thrown and the component will be blank/empty. To provide the best user experience,
     * applications should capture and handle this error to provide the user with
     * instructions/options for next steps based on the application's design and workflow.
     * Unlike other components, this will always create its own endpoint to manage the
     * session session. This endpoint will be included in event callbacks for the
     * convenience of host applications that may wish to make server calls using the
     * signer's credentials once signing is complete (e.g. to obtain copies of
     * the signed attachments.)
     */
    interface HTMLVerdocsSignElement extends Components.VerdocsSign, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsSignElementEventMap>(type: K, listener: (this: HTMLVerdocsSignElement, ev: VerdocsSignCustomEvent<HTMLVerdocsSignElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsSignElementEventMap>(type: K, listener: (this: HTMLVerdocsSignElement, ev: VerdocsSignCustomEvent<HTMLVerdocsSignElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsSignElement: {
        prototype: HTMLVerdocsSignElement;
        new (): HTMLVerdocsSignElement;
    };
    interface HTMLVerdocsSignatureDialogElementEventMap {
        "next": string;
        "exit": any;
    }
    /**
     * Display a dialog that allows the user to specify a signature image, either by using a signature-font-generated image
     * based on their full name, or by hand-drawing their signature with a mouse or tablet.
     */
    interface HTMLVerdocsSignatureDialogElement extends Components.VerdocsSignatureDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsSignatureDialogElementEventMap>(type: K, listener: (this: HTMLVerdocsSignatureDialogElement, ev: VerdocsSignatureDialogCustomEvent<HTMLVerdocsSignatureDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsSignatureDialogElementEventMap>(type: K, listener: (this: HTMLVerdocsSignatureDialogElement, ev: VerdocsSignatureDialogCustomEvent<HTMLVerdocsSignatureDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsSignatureDialogElement: {
        prototype: HTMLVerdocsSignatureDialogElement;
        new (): HTMLVerdocsSignatureDialogElement;
    };
    /**
     * Display a small loading spinner.
     * ```ts
     * <verdocs-spinner />
     * ```
     */
    interface HTMLVerdocsSpinnerElement extends Components.VerdocsSpinner, HTMLStencilElement {
    }
    var HTMLVerdocsSpinnerElement: {
        prototype: HTMLVerdocsSpinnerElement;
        new (): HTMLVerdocsSpinnerElement;
    };
    /**
     * Displays an icon and message describing a document's completion status. For convenience, the status may be passed in either
     * directly as a status field or the whole document object may be passed in.
     * If the document is provided, the status flag will indicate the document's overall status. This also makes the component clickable
     * to display a popup panel with per-recipient status data.
     * If the status is provided as a string it can be either a `TRecipientStatus` or `TDocumentStatus` value.
     */
    interface HTMLVerdocsStatusIndicatorElement extends Components.VerdocsStatusIndicator, HTMLStencilElement {
    }
    var HTMLVerdocsStatusIndicatorElement: {
        prototype: HTMLVerdocsStatusIndicatorElement;
        new (): HTMLVerdocsStatusIndicatorElement;
    };
    interface HTMLVerdocsTableElementEventMap {
        "colHeaderClick": {col: IColumn};
        "rowClick": {row: any};
    }
    /**
     * Display a simple table of data. Columns and data cells may have custom renderers defined to
     * support creating interactive table layouts.
     * ```ts
     * <verdocs-table columns={[...columns]} data={[...data]} />
     * ```
     */
    interface HTMLVerdocsTableElement extends Components.VerdocsTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTableElementEventMap>(type: K, listener: (this: HTMLVerdocsTableElement, ev: VerdocsTableCustomEvent<HTMLVerdocsTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTableElementEventMap>(type: K, listener: (this: HTMLVerdocsTableElement, ev: VerdocsTableCustomEvent<HTMLVerdocsTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTableElement: {
        prototype: HTMLVerdocsTableElement;
        new (): HTMLVerdocsTableElement;
    };
    interface HTMLVerdocsTabsElementEventMap {
        "selectTab": {tab: ITab; index: number};
    }
    /**
     * Display a simple row of selectable tabs. This is a controlled element.
     * The parent must adjust selectedTab as selection events are fired.
     * ```ts
     * <verdocs-tabs tabs={[...tabs]} />
     * ```
     */
    interface HTMLVerdocsTabsElement extends Components.VerdocsTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTabsElementEventMap>(type: K, listener: (this: HTMLVerdocsTabsElement, ev: VerdocsTabsCustomEvent<HTMLVerdocsTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTabsElementEventMap>(type: K, listener: (this: HTMLVerdocsTabsElement, ev: VerdocsTabsCustomEvent<HTMLVerdocsTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTabsElement: {
        prototype: HTMLVerdocsTabsElement;
        new (): HTMLVerdocsTabsElement;
    };
    interface HTMLVerdocsTemplateAttachmentsElementEventMap {
        "exit": any;
        "next": {template: ITemplate};
        "templateUpdated": {endpoint: VerdocsEndpoint; template: ITemplate; event: string};
        "sdkError": SDKError;
    }
    /**
     * Displays an edit form that allows the user to view, add, or remove a template's attachments.
     * Note that an active session and valid template ID must be supplied.
     */
    interface HTMLVerdocsTemplateAttachmentsElement extends Components.VerdocsTemplateAttachments, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateAttachmentsElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateAttachmentsElement, ev: VerdocsTemplateAttachmentsCustomEvent<HTMLVerdocsTemplateAttachmentsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateAttachmentsElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateAttachmentsElement, ev: VerdocsTemplateAttachmentsCustomEvent<HTMLVerdocsTemplateAttachmentsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateAttachmentsElement: {
        prototype: HTMLVerdocsTemplateAttachmentsElement;
        new (): HTMLVerdocsTemplateAttachmentsElement;
    };
    interface HTMLVerdocsTemplateBuildTabsElementEventMap {
        "sdkError": SDKError;
        "stepChanged": TVerdocsBuildStep1;
    }
    /**
     * Display a set of tabs for the template builder.
     */
    interface HTMLVerdocsTemplateBuildTabsElement extends Components.VerdocsTemplateBuildTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateBuildTabsElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateBuildTabsElement, ev: VerdocsTemplateBuildTabsCustomEvent<HTMLVerdocsTemplateBuildTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateBuildTabsElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateBuildTabsElement, ev: VerdocsTemplateBuildTabsCustomEvent<HTMLVerdocsTemplateBuildTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateBuildTabsElement: {
        prototype: HTMLVerdocsTemplateBuildTabsElement;
        new (): HTMLVerdocsTemplateBuildTabsElement;
    };
    /**
     * Displays a summary of a template
     */
    interface HTMLVerdocsTemplateCardElement extends Components.VerdocsTemplateCard, HTMLStencilElement {
    }
    var HTMLVerdocsTemplateCardElement: {
        prototype: HTMLVerdocsTemplateCardElement;
        new (): HTMLVerdocsTemplateCardElement;
    };
    interface HTMLVerdocsTemplateCreateElementEventMap {
        "exit": any;
        "next": ITemplate;
        "sdkError": SDKError;
        "templateCreated": {endpoint: VerdocsEndpoint; template: ITemplate; templateId: string};
    }
    /**
     * Displays a file upload mechanism suitable for the first step of creating a template.
     * This is typically the first step in a template creation workflow.
     */
    interface HTMLVerdocsTemplateCreateElement extends Components.VerdocsTemplateCreate, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateCreateElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateCreateElement, ev: VerdocsTemplateCreateCustomEvent<HTMLVerdocsTemplateCreateElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateCreateElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateCreateElement, ev: VerdocsTemplateCreateCustomEvent<HTMLVerdocsTemplateCreateElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateCreateElement: {
        prototype: HTMLVerdocsTemplateCreateElement;
        new (): HTMLVerdocsTemplateCreateElement;
    };
    interface HTMLVerdocsTemplateDocumentPageElementEventMap {
        "pageRendered": IDocumentPageInfo;
    }
    /**
     * Represents one document page. This is primarily a layout container used to coordinate positions of
     * page-related layers such as the page itself, signature fields, etc. It is not intended to be used
     * on its own as an individual component.
     */
    interface HTMLVerdocsTemplateDocumentPageElement extends Components.VerdocsTemplateDocumentPage, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateDocumentPageElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateDocumentPageElement, ev: VerdocsTemplateDocumentPageCustomEvent<HTMLVerdocsTemplateDocumentPageElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateDocumentPageElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateDocumentPageElement, ev: VerdocsTemplateDocumentPageCustomEvent<HTMLVerdocsTemplateDocumentPageElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateDocumentPageElement: {
        prototype: HTMLVerdocsTemplateDocumentPageElement;
        new (): HTMLVerdocsTemplateDocumentPageElement;
    };
    interface HTMLVerdocsTemplateFieldPropertiesElementEventMap {
        "close": any;
        "delete": {templateId: string; roleName: string};
        "settingsChanged": {fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField};
        "sdkError": SDKError;
    }
    /**
     * Displays an edit form that allows the user to adjust a field's settings.
     */
    interface HTMLVerdocsTemplateFieldPropertiesElement extends Components.VerdocsTemplateFieldProperties, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateFieldPropertiesElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateFieldPropertiesElement, ev: VerdocsTemplateFieldPropertiesCustomEvent<HTMLVerdocsTemplateFieldPropertiesElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateFieldPropertiesElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateFieldPropertiesElement, ev: VerdocsTemplateFieldPropertiesCustomEvent<HTMLVerdocsTemplateFieldPropertiesElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateFieldPropertiesElement: {
        prototype: HTMLVerdocsTemplateFieldPropertiesElement;
        new (): HTMLVerdocsTemplateFieldPropertiesElement;
    };
    interface HTMLVerdocsTemplateFieldsElementEventMap {
        "sdkError": SDKError;
        "templateUpdated": {endpoint: VerdocsEndpoint; template: ITemplate; event: string};
        "fieldsUpdated": {endpoint: VerdocsEndpoint; templateId: string; event: 'added' | 'deleted' | 'updated'; fields: ITemplateField[]};
    }
    /**
     * Displays a builder experience for laying out fields in a template. Note that this experience requires a large display area to
     * present all of the required controls, so it is primarily intended to be used in desktop environments.
     */
    interface HTMLVerdocsTemplateFieldsElement extends Components.VerdocsTemplateFields, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateFieldsElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateFieldsElement, ev: VerdocsTemplateFieldsCustomEvent<HTMLVerdocsTemplateFieldsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateFieldsElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateFieldsElement, ev: VerdocsTemplateFieldsCustomEvent<HTMLVerdocsTemplateFieldsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateFieldsElement: {
        prototype: HTMLVerdocsTemplateFieldsElement;
        new (): HTMLVerdocsTemplateFieldsElement;
    };
    interface HTMLVerdocsTemplateNameElementEventMap {
        "close": any;
        "sdkError": SDKError;
        "templateUpdated": {endpoint: VerdocsEndpoint; template: ITemplate; event: string};
    }
    /**
     * Displays an edit form that allows the user to rename a template. Note that an active session and valid template ID must be supplied.
     */
    interface HTMLVerdocsTemplateNameElement extends Components.VerdocsTemplateName, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateNameElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateNameElement, ev: VerdocsTemplateNameCustomEvent<HTMLVerdocsTemplateNameElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateNameElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateNameElement, ev: VerdocsTemplateNameCustomEvent<HTMLVerdocsTemplateNameElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateNameElement: {
        prototype: HTMLVerdocsTemplateNameElement;
        new (): HTMLVerdocsTemplateNameElement;
    };
    interface HTMLVerdocsTemplateRemindersElementEventMap {
        "close": any;
        "sdkError": SDKError;
        "templateUpdated": {endpoint: VerdocsEndpoint; template: ITemplate; event: string};
    }
    /**
     * Displays an edit form that allows the user to adjust a template's reminders.
     */
    interface HTMLVerdocsTemplateRemindersElement extends Components.VerdocsTemplateReminders, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateRemindersElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateRemindersElement, ev: VerdocsTemplateRemindersCustomEvent<HTMLVerdocsTemplateRemindersElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateRemindersElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateRemindersElement, ev: VerdocsTemplateRemindersCustomEvent<HTMLVerdocsTemplateRemindersElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateRemindersElement: {
        prototype: HTMLVerdocsTemplateRemindersElement;
        new (): HTMLVerdocsTemplateRemindersElement;
    };
    interface HTMLVerdocsTemplateRolePropertiesElementEventMap {
        "close": any;
        "delete": {templateId: string; roleName: string};
        "sdkError": SDKError;
    }
    /**
     * Display an edit form that allows the user to adjust a role's setitngs.
     */
    interface HTMLVerdocsTemplateRolePropertiesElement extends Components.VerdocsTemplateRoleProperties, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateRolePropertiesElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateRolePropertiesElement, ev: VerdocsTemplateRolePropertiesCustomEvent<HTMLVerdocsTemplateRolePropertiesElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateRolePropertiesElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateRolePropertiesElement, ev: VerdocsTemplateRolePropertiesCustomEvent<HTMLVerdocsTemplateRolePropertiesElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateRolePropertiesElement: {
        prototype: HTMLVerdocsTemplateRolePropertiesElement;
        new (): HTMLVerdocsTemplateRolePropertiesElement;
    };
    interface HTMLVerdocsTemplateRolesElementEventMap {
        "next": any;
        "exit": any;
        "sdkError": SDKError;
        "rolesUpdated": {endpoint: VerdocsEndpoint; templateId: string; event: 'added' | 'deleted' | 'updated'; roles: IRole[]};
    }
    /**
     * Displays an edit form that allows the user to adjust a template's roles and workflow.
     */
    interface HTMLVerdocsTemplateRolesElement extends Components.VerdocsTemplateRoles, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateRolesElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateRolesElement, ev: VerdocsTemplateRolesCustomEvent<HTMLVerdocsTemplateRolesElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateRolesElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateRolesElement, ev: VerdocsTemplateRolesCustomEvent<HTMLVerdocsTemplateRolesElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateRolesElement: {
        prototype: HTMLVerdocsTemplateRolesElement;
        new (): HTMLVerdocsTemplateRolesElement;
    };
    interface HTMLVerdocsTemplateSenderElementEventMap {
        "close": any;
        "sdkError": SDKError;
    }
    /**
     * Display a dialog that allows a template sender to be selected.
     */
    interface HTMLVerdocsTemplateSenderElement extends Components.VerdocsTemplateSender, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateSenderElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateSenderElement, ev: VerdocsTemplateSenderCustomEvent<HTMLVerdocsTemplateSenderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateSenderElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateSenderElement, ev: VerdocsTemplateSenderCustomEvent<HTMLVerdocsTemplateSenderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateSenderElement: {
        prototype: HTMLVerdocsTemplateSenderElement;
        new (): HTMLVerdocsTemplateSenderElement;
    };
    interface HTMLVerdocsTemplateStarElementEventMap {
        "starChange": {templateId: string; starred: boolean; count: number};
        "sdkError": SDKError;
    }
    /**
     * Displays a clickable star that allows users to mark frequently-used templates.
     */
    interface HTMLVerdocsTemplateStarElement extends Components.VerdocsTemplateStar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateStarElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateStarElement, ev: VerdocsTemplateStarCustomEvent<HTMLVerdocsTemplateStarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateStarElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateStarElement, ev: VerdocsTemplateStarCustomEvent<HTMLVerdocsTemplateStarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateStarElement: {
        prototype: HTMLVerdocsTemplateStarElement;
        new (): HTMLVerdocsTemplateStarElement;
    };
    /**
     * Displays a message listing a template's tags.
     */
    interface HTMLVerdocsTemplateTagsElement extends Components.VerdocsTemplateTags, HTMLStencilElement {
    }
    var HTMLVerdocsTemplateTagsElement: {
        prototype: HTMLVerdocsTemplateTagsElement;
        new (): HTMLVerdocsTemplateTagsElement;
    };
    interface HTMLVerdocsTemplateVisibilityElementEventMap {
        "close": any;
        "sdkError": SDKError;
        "templateUpdated": {endpoint: VerdocsEndpoint; template: ITemplate; event: string};
    }
    /**
     * Displays an edit form that allows the user to adjust a template's visibility.
     */
    interface HTMLVerdocsTemplateVisibilityElement extends Components.VerdocsTemplateVisibility, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplateVisibilityElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateVisibilityElement, ev: VerdocsTemplateVisibilityCustomEvent<HTMLVerdocsTemplateVisibilityElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplateVisibilityElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplateVisibilityElement, ev: VerdocsTemplateVisibilityCustomEvent<HTMLVerdocsTemplateVisibilityElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplateVisibilityElement: {
        prototype: HTMLVerdocsTemplateVisibilityElement;
        new (): HTMLVerdocsTemplateVisibilityElement;
    };
    interface HTMLVerdocsTemplatesListElementEventMap {
        "sdkError": SDKError;
        "viewTemplate": {endpoint: VerdocsEndpoint; template: ITemplate};
        "signNow": {endpoint: VerdocsEndpoint; template: ITemplate};
        "submittedData": {endpoint: VerdocsEndpoint; template: ITemplate};
        "editTemplate": {endpoint: VerdocsEndpoint; template: ITemplate};
        "templateDeleted": {endpoint: VerdocsEndpoint; template: ITemplate};
        "changeSort": IGetTemplateSummarySortBy;
        "changeSharing": 'all' | 'personal' | 'shared' | 'public';
        "changeStarred": 'all' | 'starred' | 'unstarred';
        "changeName": string;
    }
    /**
     * Displays a list of envelopes matching specified conditions.
     */
    interface HTMLVerdocsTemplatesListElement extends Components.VerdocsTemplatesList, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsTemplatesListElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplatesListElement, ev: VerdocsTemplatesListCustomEvent<HTMLVerdocsTemplatesListElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsTemplatesListElementEventMap>(type: K, listener: (this: HTMLVerdocsTemplatesListElement, ev: VerdocsTemplatesListCustomEvent<HTMLVerdocsTemplatesListElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsTemplatesListElement: {
        prototype: HTMLVerdocsTemplatesListElement;
        new (): HTMLVerdocsTemplatesListElement;
    };
    /**
     * Display a text input field. This is just a standard HTML input field with minimal markup to fit the
     * visual styles of the other components. Note that events "bubble" from the input field to the container,
     * so you can subscribe to the same DOM events (input, blur, etc) that a normal input would emit.
     * ```ts
     * <verdocs-text-input type="text" label="Name" placeholder="Enter your name..." value="" />
     * ```
     */
    interface HTMLVerdocsTextInputElement extends Components.VerdocsTextInput, HTMLStencilElement {
    }
    var HTMLVerdocsTextInputElement: {
        prototype: HTMLVerdocsTextInputElement;
        new (): HTMLVerdocsTextInputElement;
    };
    /**
     * Displays a label and a set of buttons, also allowing a default selection of a button.
     * ```ts
     * <verdocs-toggle options={[...options]} theme="light"></verdocs-toggle>
     * ```
     */
    interface HTMLVerdocsToggleElement extends Components.VerdocsToggle, HTMLStencilElement {
    }
    var HTMLVerdocsToggleElement: {
        prototype: HTMLVerdocsToggleElement;
        new (): HTMLVerdocsToggleElement;
    };
    interface HTMLVerdocsToggleButtonElementEventMap {
        "toggle": {active: boolean};
    }
    /**
     * Displays a single button that can be toggled on or off by clicking it.
     * ```ts
     * <verdocs-toggle-button icon={MessageIcon} size="normal" active={true} />
     * ```
     */
    interface HTMLVerdocsToggleButtonElement extends Components.VerdocsToggleButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsToggleButtonElementEventMap>(type: K, listener: (this: HTMLVerdocsToggleButtonElement, ev: VerdocsToggleButtonCustomEvent<HTMLVerdocsToggleButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsToggleButtonElementEventMap>(type: K, listener: (this: HTMLVerdocsToggleButtonElement, ev: VerdocsToggleButtonCustomEvent<HTMLVerdocsToggleButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsToggleButtonElement: {
        prototype: HTMLVerdocsToggleButtonElement;
        new (): HTMLVerdocsToggleButtonElement;
    };
    /**
     * Displays a simple help icon. Upon hover or focus, a tooltip will be displayed with help text.
     * ```ts
     * <verdocs-toolbar-icon text="Sample tooltip text" icon={CalendarIcon} />
     * ```
     */
    interface HTMLVerdocsToolbarIconElement extends Components.VerdocsToolbarIcon, HTMLStencilElement {
    }
    var HTMLVerdocsToolbarIconElement: {
        prototype: HTMLVerdocsToolbarIconElement;
        new (): HTMLVerdocsToolbarIconElement;
    };
    interface HTMLVerdocsUploadDialogElementEventMap {
        "exit": any;
        "next": IFileWithData[];
    }
    /**
     * Display a file upload tool. Note that the file is not actually transmitted, so it may be used by
     * callers with a variety of workflows. Instead, data about the chosen file will be passed to the
     * caller via the onNext event handler.
     */
    interface HTMLVerdocsUploadDialogElement extends Components.VerdocsUploadDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsUploadDialogElementEventMap>(type: K, listener: (this: HTMLVerdocsUploadDialogElement, ev: VerdocsUploadDialogCustomEvent<HTMLVerdocsUploadDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsUploadDialogElementEventMap>(type: K, listener: (this: HTMLVerdocsUploadDialogElement, ev: VerdocsUploadDialogCustomEvent<HTMLVerdocsUploadDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsUploadDialogElement: {
        prototype: HTMLVerdocsUploadDialogElement;
        new (): HTMLVerdocsUploadDialogElement;
    };
    interface HTMLVerdocsViewElementEventMap {
        "sdkError": SDKError;
        "envelopeUpdated": {endpoint: VerdocsEndpoint; envelope: IEnvelope; event: string};
        "another": any;
        "view": any;
        "next": any;
    }
    /**
     * Render the documents attached to an envelope in read-only (view) mode. All documents are displayed in order.
     */
    interface HTMLVerdocsViewElement extends Components.VerdocsView, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVerdocsViewElementEventMap>(type: K, listener: (this: HTMLVerdocsViewElement, ev: VerdocsViewCustomEvent<HTMLVerdocsViewElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVerdocsViewElementEventMap>(type: K, listener: (this: HTMLVerdocsViewElement, ev: VerdocsViewCustomEvent<HTMLVerdocsViewElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVerdocsViewElement: {
        prototype: HTMLVerdocsViewElement;
        new (): HTMLVerdocsViewElement;
    };
    interface HTMLElementTagNameMap {
        "verdocs-activity-box": HTMLVerdocsActivityBoxElement;
        "verdocs-auth": HTMLVerdocsAuthElement;
        "verdocs-build": HTMLVerdocsBuildElement;
        "verdocs-button": HTMLVerdocsButtonElement;
        "verdocs-button-panel": HTMLVerdocsButtonPanelElement;
        "verdocs-checkbox": HTMLVerdocsCheckboxElement;
        "verdocs-component-error": HTMLVerdocsComponentErrorElement;
        "verdocs-contact-picker": HTMLVerdocsContactPickerElement;
        "verdocs-dialog": HTMLVerdocsDialogElement;
        "verdocs-dropdown": HTMLVerdocsDropdownElement;
        "verdocs-envelope-document-page": HTMLVerdocsEnvelopeDocumentPageElement;
        "verdocs-envelope-recipient-link": HTMLVerdocsEnvelopeRecipientLinkElement;
        "verdocs-envelope-recipient-summary": HTMLVerdocsEnvelopeRecipientSummaryElement;
        "verdocs-envelope-sidebar": HTMLVerdocsEnvelopeSidebarElement;
        "verdocs-envelopes-list": HTMLVerdocsEnvelopesListElement;
        "verdocs-field-attachment": HTMLVerdocsFieldAttachmentElement;
        "verdocs-field-checkbox": HTMLVerdocsFieldCheckboxElement;
        "verdocs-field-date": HTMLVerdocsFieldDateElement;
        "verdocs-field-dropdown": HTMLVerdocsFieldDropdownElement;
        "verdocs-field-initial": HTMLVerdocsFieldInitialElement;
        "verdocs-field-payment": HTMLVerdocsFieldPaymentElement;
        "verdocs-field-radio-button": HTMLVerdocsFieldRadioButtonElement;
        "verdocs-field-signature": HTMLVerdocsFieldSignatureElement;
        "verdocs-field-textarea": HTMLVerdocsFieldTextareaElement;
        "verdocs-field-textbox": HTMLVerdocsFieldTextboxElement;
        "verdocs-field-timestamp": HTMLVerdocsFieldTimestampElement;
        "verdocs-file-chooser": HTMLVerdocsFileChooserElement;
        "verdocs-help-icon": HTMLVerdocsHelpIconElement;
        "verdocs-initial-dialog": HTMLVerdocsInitialDialogElement;
        "verdocs-kba-dialog": HTMLVerdocsKbaDialogElement;
        "verdocs-loader": HTMLVerdocsLoaderElement;
        "verdocs-ok-dialog": HTMLVerdocsOkDialogElement;
        "verdocs-organization-card": HTMLVerdocsOrganizationCardElement;
        "verdocs-pagination": HTMLVerdocsPaginationElement;
        "verdocs-portal": HTMLVerdocsPortalElement;
        "verdocs-preview": HTMLVerdocsPreviewElement;
        "verdocs-progress-bar": HTMLVerdocsProgressBarElement;
        "verdocs-quick-filter": HTMLVerdocsQuickFilterElement;
        "verdocs-quick-functions": HTMLVerdocsQuickFunctionsElement;
        "verdocs-radio-button": HTMLVerdocsRadioButtonElement;
        "verdocs-search": HTMLVerdocsSearchElement;
        "verdocs-search-box": HTMLVerdocsSearchBoxElement;
        "verdocs-search-tabs": HTMLVerdocsSearchTabsElement;
        "verdocs-select-input": HTMLVerdocsSelectInputElement;
        "verdocs-send": HTMLVerdocsSendElement;
        "verdocs-settings": HTMLVerdocsSettingsElement;
        "verdocs-settings-api-keys": HTMLVerdocsSettingsApiKeysElement;
        "verdocs-settings-members": HTMLVerdocsSettingsMembersElement;
        "verdocs-settings-organization": HTMLVerdocsSettingsOrganizationElement;
        "verdocs-settings-profile": HTMLVerdocsSettingsProfileElement;
        "verdocs-sign": HTMLVerdocsSignElement;
        "verdocs-signature-dialog": HTMLVerdocsSignatureDialogElement;
        "verdocs-spinner": HTMLVerdocsSpinnerElement;
        "verdocs-status-indicator": HTMLVerdocsStatusIndicatorElement;
        "verdocs-table": HTMLVerdocsTableElement;
        "verdocs-tabs": HTMLVerdocsTabsElement;
        "verdocs-template-attachments": HTMLVerdocsTemplateAttachmentsElement;
        "verdocs-template-build-tabs": HTMLVerdocsTemplateBuildTabsElement;
        "verdocs-template-card": HTMLVerdocsTemplateCardElement;
        "verdocs-template-create": HTMLVerdocsTemplateCreateElement;
        "verdocs-template-document-page": HTMLVerdocsTemplateDocumentPageElement;
        "verdocs-template-field-properties": HTMLVerdocsTemplateFieldPropertiesElement;
        "verdocs-template-fields": HTMLVerdocsTemplateFieldsElement;
        "verdocs-template-name": HTMLVerdocsTemplateNameElement;
        "verdocs-template-reminders": HTMLVerdocsTemplateRemindersElement;
        "verdocs-template-role-properties": HTMLVerdocsTemplateRolePropertiesElement;
        "verdocs-template-roles": HTMLVerdocsTemplateRolesElement;
        "verdocs-template-sender": HTMLVerdocsTemplateSenderElement;
        "verdocs-template-star": HTMLVerdocsTemplateStarElement;
        "verdocs-template-tags": HTMLVerdocsTemplateTagsElement;
        "verdocs-template-visibility": HTMLVerdocsTemplateVisibilityElement;
        "verdocs-templates-list": HTMLVerdocsTemplatesListElement;
        "verdocs-text-input": HTMLVerdocsTextInputElement;
        "verdocs-toggle": HTMLVerdocsToggleElement;
        "verdocs-toggle-button": HTMLVerdocsToggleButtonElement;
        "verdocs-toolbar-icon": HTMLVerdocsToolbarIconElement;
        "verdocs-upload-dialog": HTMLVerdocsUploadDialogElement;
        "verdocs-view": HTMLVerdocsViewElement;
    }
}
declare namespace LocalJSX {
    /**
     * Displays a box showing summaries of envelopes matching specified conditions. Activity Boxes show a fixed number
     * of items because they are meant to be laid out horizontally (if the user's screen is large enough) and this helps
     * them appear more visually balanced.
     */
    interface VerdocsActivityBox {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * The title to display on the box ("title" is a reserved word). This is optional, and if not set, the title will be derived from the view. Set this to an empty string to hide the header.
         */
        "header"?: string | undefined;
        /**
          * The number of items to display.
         */
        "items"?: number;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsActivityBoxCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user clicks View All in the title bar. The current view will be included in the event details to help the host application navigate the user to the appropriate screen for the request. Note that the verdocs-envelopes-list control uses the same "view" parameter, so host applications can typically pass this value through directly. This button is not visible if the header is hidden.
         */
        "onViewAll"?: (event: VerdocsActivityBoxCustomEvent<{endpoint: VerdocsEndpoint; view: string}>) => void;
        /**
          * Event fired when the user clicks an activity entry. Typically the host application will use this to navigate to the envelope detail view.
         */
        "onViewEnvelope"?: (event: VerdocsActivityBoxCustomEvent<{endpoint: VerdocsEndpoint; entry: IActivityEntry}>) => void;
        /**
          * The filtered view to display. "completed" will show envelopes that have been submitted. "action" will show envelopes where the user is a recipient and the envelope is not completed. "waiting" will show only envelopes where the user is the sender and the envelope is not completed.
         */
        "view"?: 'completed' | 'action' | 'waiting';
    }
    /**
     * Display an authentication dialog that allows the user to login or sign up. If the user is already authenticated
     * with a valid session, this component will hide itself and fire the success callback immediately. It is up to the
     * host application to render the next appropriate view for the application.
     * To simplify UI development, a visibility flag can force this component to never display. This
     * allows you to susbcribe to notifications from client apps without calling the lower-level JS SDK.
     * This embed is responsive / mobile-friendly, but the calling application should provide at least a 300px wide
     * container to allow sufficient space for the required forms.
     * ```ts
     * <verdocs-auth onAuthenticated={e => console.log('Authentication state:', e.detail)} />
     * ```
     */
    interface VerdocsAuth {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * By default, a Verdocs logo will be displayed above the login/signup forms. This may be used to override its source. (Alternatively, you may simply hide it via CSS overrides.) Logos should be in SVG format for best results.
         */
        "logo"?: string;
        /**
          * Event fired when session authentication process has completed. Check the event contents for completion status. This event will always be called at least once, when the component is first rendered.
         */
        "onAuthenticated"?: (event: VerdocsAuthCustomEvent<IAuthStatus>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsAuthCustomEvent<SDKError>) => void;
        /**
          * Normally, if the user has a valid session, this embed will be invisible, otherwise it will display login / signup forms. If this is set to false, this embed will be invisible in both cases. Apps may use this to verify if a user has a valid session without needing a separate call to Verdocs JS SDK.
         */
        "visible"?: boolean;
    }
    /**
     * Display a template building experience.
     * ```ts
     * <verdocs-build templateId={templateId} />
     * ```
     */
    interface VerdocsBuild {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when roles are updated in the roles step.
         */
        "onRolesUpdated"?: (event: VerdocsBuildCustomEvent<{endpoint: VerdocsEndpoint; templateId: string; event: 'added' | 'deleted' | 'updated'; roles: IRole[]}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsBuildCustomEvent<SDKError>) => void;
        /**
          * The user completed the Send form and clicked send.
         */
        "onSend"?: (event: VerdocsBuildCustomEvent<{roles: ICreateEnvelopeRole[]; name: string; template_id: string}>) => void;
        /**
          * Event fired when the user selects a different step.
         */
        "onStepChanged"?: (event: VerdocsBuildCustomEvent<TVerdocsBuildStep>) => void;
        /**
          * Event fired when the template is created by the upload step.
         */
        "onTemplateCreated"?: (event: VerdocsBuildCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate; event: string}>) => void;
        /**
          * Event fired when the template is updated in any way. May be used for tasks such as cache invalidation or reporting to other systems.
         */
        "onTemplateUpdated"?: (event: VerdocsBuildCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate; event: string}>) => void;
        /**
          * The step in the creation process to display.
         */
        "step"?: TVerdocsBuildStep;
        /**
          * The ID of the template to create the document from. Unlike most other components, this is an optional parameter here. If the template ID is known, `step` may also be specified to force displaying a specific step in the creation process. If it is not specified, `step` will be ignored and the create step will be shown.
         */
        "templateId"?: string | null;
    }
    /**
     * A simple button, with consistent styling to other controls in the design system.
     * ```ts
     * <verdocs-button label="Click Me" size="normal" variant="standard" />
     * ```
     */
    interface VerdocsButton {
        /**
          * Whether the button should be disabled.
         */
        "disabled"?: boolean;
        /**
          * If desired, a suffix icon for the button.
         */
        "endIcon"?: string | null;
        /**
          * The label for the button.
         */
        "label": string;
        /**
          * The size (height) of the button.
         */
        "size"?: 'small' | 'normal' | 'medium' | 'large';
        /**
          * If desired, a prefix icon for the button.
         */
        "startIcon"?: string | null;
        /**
          * The type of the button.
         */
        "type"?: 'button' | 'submit' | 'reset';
        /**
          * The display variant of the button.
         */
        "variant"?: 'standard' | 'text' | 'outline';
    }
    /**
     * Display an icon button that triggers a drop-down panel that can display
     * arbitrary child content, such as metadata, forms, or other controls.
     * ```ts
     *   <verdocs-button-panel .icon=${icon}>
     *     <h6>Field Settings</h6>
     *     <form>
     *     <p>
     *       <label>Field Name</label>
     *       <input type="text" placeholder="Field Name..." />
     *     </p>
     *     </form>
     *   </verdocs-button-panel>
     * ```
     */
    interface VerdocsButtonPanel {
        /**
          * SVG icon to display
         */
        "icon"?: string;
    }
    /**
     * Displays a check box. Note that this is different from the `verdocs-field-checkbox` component, which is designed
     * to be used in signing experiences and contains settings that connect to template fields. This is just a simple check
     * box for UI displays e.g. dialog boxes.
     * This control encapsulates a standard HTML checkbox. To subscribe to change events, connect an `onChange`
     * handler. Sample usage:
     * ```ts
     * <verdocs-checkbox
     *    value="on"
     *    name="thingEnabled"
     *    checked={this.thingEnabled}
     *    onInput={(e: any) => (this.thingEnabled = e.target.checked)}
     * />
     * ```
     */
    interface VerdocsCheckbox {
        /**
          * Whether the radio button is currently selected.
         */
        "checked"?: boolean;
        /**
          * If set, the button will still be displayed but not selectable.
         */
        "disabled"?: boolean;
        /**
          * Label to display. Leave blank for no label. The label will be displayed to the right of the checkbox, but may be repositioned with CSS.
         */
        "label"?: string;
        /**
          * HTML form field name for the input.
         */
        "name"?: string;
        /**
          * Style of checkbox to render. Use 'dark' when rendering on a dark background.
         */
        "theme"?: 'light' | 'dark';
        /**
          * Value to track with the input. Value is not used internally by this component but is sometimes useful to set because it can be retrieved in event handlers via e.target.value. This can be used to identify which checkbox was clicked in a checkbox group.
         */
        "value"?: string;
    }
    /**
     * Render a simple error message.
     */
    interface VerdocsComponentError {
        /**
          * The message to display.
         */
        "message"?: string;
    }
    /**
     * Displays a contact picker suitable for filling out Recipient objects when sending Documents.
     * This picker can also be integrated with a backend to provide contact list / suggestion / address-book style behavior. As the
     * user interacts with the component, the text entered in the name field is sent back to the parent via the `searchContacts` event.
     * The parent can use that text as a query string to call a backend to obtain appropriate contacts to show. This list may also be
     * hard-coded ahead of time to provide the user with smart suggestions on initial display, such as "Recently Used" contacts, or
     * to always display the user's own contact record.
     */
    interface VerdocsContactPicker {
        /**
          * If set, suggestions will be displayed in a drop-down list to the user. It is recommended that the number of suggestions be limited to the 5 best matching records.
         */
        "contactSuggestions"?: (IEmailContact | IPhoneContact)[];
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the step is cancelled. This is called exit to avoid conflicts with the JS-reserved "cancel" event name.
         */
        "onExit"?: (event: VerdocsContactPickerCustomEvent<any>) => void;
        /**
          * Event fired when the user changes the type.
         */
        "onNext"?: (event: VerdocsContactPickerCustomEvent<IContactSelectEvent>) => void;
        /**
          * Event fired when the user enters text in the search field. The calling application may use this to update the `contactSuggestions` property.
         */
        "onSearchContacts"?: (event: VerdocsContactPickerCustomEvent<IContactSearchEvent>) => void;
        /**
          * The role that this contact will be assigned to.
         */
        "templateRole"?: IRole | null;
    }
    /**
     * Display a simple dialog where the contents are provided via slots.
     */
    interface VerdocsDialog {
        /**
          * Event fired when the dialog is dismissed by clicking the background overlay.
         */
        "onExit"?: (event: VerdocsDialogCustomEvent<any>) => void;
    }
    /**
     * Display a drop-down menu button. A menu of the specified options will be displayed when the button is pressed. The menu will be hidden
     * when the button is pressed again, or an option is selected. Separators may be created by supplying an entry with an empty label.
     * ```ts
     * <verdocs-dropdown
     *   options={[
     *     {label: 'Option 1', disabled: true},
     *     {label: 'Option 2', id: '2'}
     *     {label: ''}
     *     {label: 'Option 3', id: '2'}
     *    ]}
     *   label="OK" onClick={() => (console.log('OK clicked'))}
     * />
     * ```
     */
    interface VerdocsDropdown {
        /**
          * Event fired when a menu option is clicked. Web Component events need to be "composed" to cross the Shadow DOM and be received by parent frameworks.
         */
        "onOptionSelected"?: (event: VerdocsDropdownCustomEvent<IMenuOption>) => void;
        /**
          * The menu options to display.
         */
        "options"?: IMenuOption[];
    }
    /**
     * Represents one document page. This is primarily a layout container used to coordinate positions of
     * page-related layers such as the page itself, signature fields, etc. It is not intended to be used
     * on its own as an individual component.
     */
    interface VerdocsEnvelopeDocumentPage {
        /**
          * The ID of the document to display.
         */
        "documentId"?: string;
        /**
          * The endpoint to load from.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * The ID of the envelope the document is for.
         */
        "envelopeId"?: string;
        /**
          * The layers that will be rendered. The DOM structure will be a DIV container with one child DIV for each layer. The parent DIV will have a unique ID, and each child DIV will have that ID with the layer name appended, e.g. if `pages` was ['page', 'fields'] the structure will be:  ```     <div id="verdocs-envelope-document-page-ker2fr1p9">       <div id="verdocs-envelope-document-page-ker2fr1p9-page"></div>       <div id="verdocs-envelope-document-page-ker2fr1p9-fields"></div>     </div> ```
         */
        "layers"?: IPageLayer[];
        /**
          * Fired when a page has been rendered. This is also fired when the page is resized.
         */
        "onPageRendered"?: (event: VerdocsEnvelopeDocumentPageCustomEvent<IDocumentPageInfo>) => void;
        /**
          * The page number being rendered. (Reminder: page numbers are 1-based.)
         */
        "pageNumber"?: number;
        "type"?: 'original' | 'filled' | 'certificate';
        /**
          * The "virtual" height of the page canvas.  Defaults to 792 which at 72dpi is 11" tall. This is used to compute the aspect ratio of the final rendered element when scaling up/down.
         */
        "virtualHeight"?: number;
        /**
          * The "virtual" width of the page canvas. Defaults to 612 which at 72dpi is 8.5" wide. This is used to compute the aspect ratio of the final rendered element when scaling up/down.
         */
        "virtualWidth"?: number;
    }
    /**
     * Displays a single recipient from an envelope, with the opportunity to copy an in-person
     * signing link for that recipient to use.
     */
    interface VerdocsEnvelopeRecipientLink {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * The envelope ID to edit.
         */
        "envelopeId"?: string;
        /**
          * Event fired when the user clicks Done to proceed. It is up to the host application to redirect the user to the appropriate next workflow step.
         */
        "onNext"?: (event: VerdocsEnvelopeRecipientLinkCustomEvent<{envelope: IEnvelope}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsEnvelopeRecipientLinkCustomEvent<SDKError>) => void;
        /**
          * The role to load.
         */
        "roleName"?: string;
    }
    /**
     * Displays a list of recipients with options to get in-person signing links for each one.
     */
    interface VerdocsEnvelopeRecipientSummary {
        /**
          * Enable or disable the Done button.
         */
        "canDone"?: boolean;
        /**
          * Enable or disable the Send Another button.
         */
        "canSendAnother"?: boolean;
        /**
          * Enable or disable the View button.
         */
        "canView"?: boolean;
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * The envelope ID to edit.
         */
        "envelopeId"?: string;
        /**
          * Event fired when the user clicks Send Another to proceed. It is up to the host application to redirect the user to the appropriate next workflow step.
         */
        "onAnother"?: (event: VerdocsEnvelopeRecipientSummaryCustomEvent<{envelope: IEnvelope}>) => void;
        /**
          * Event fired when the user clicks Done to proceed. It is up to the host application to redirect the user to the appropriate next workflow step.
         */
        "onNext"?: (event: VerdocsEnvelopeRecipientSummaryCustomEvent<{envelope: IEnvelope}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsEnvelopeRecipientSummaryCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user clicks Send Another to proceed. It is up to the host application to redirect the user to the appropriate next workflow step.
         */
        "onView"?: (event: VerdocsEnvelopeRecipientSummaryCustomEvent<{envelope: IEnvelope}>) => void;
    }
    /**
     * Displays a file upload mechanism suitable for the first step of creating a template.
     * This is typically the first step in a template creation workflow.
     */
    interface VerdocsEnvelopeSidebar {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * The envelope ID to render. Set ONE OF templateId or envelopeId. If both are set, envelopeId will be ignored.
         */
        "envelopeId"?: string;
        /**
          * Event fired when the user clicks Send Another in the Manage Recipients dialog. It is up to the host application to redirect the user to the appropriate next workflow step.
         */
        "onAnother"?: (event: VerdocsEnvelopeSidebarCustomEvent<{envelope: IEnvelope}>) => void;
        /**
          * Event fired when the envelope is updated in any way. May be used for tasks such as cache invalidation or reporting to other systems.
         */
        "onEnvelopeUpdated"?: (event: VerdocsEnvelopeSidebarCustomEvent<{endpoint: VerdocsEndpoint; envelope: IEnvelope; event: string}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsEnvelopeSidebarCustomEvent<SDKError>) => void;
        /**
          * Event fired when the sidebar is opened or closed.
         */
        "onToggle"?: (event: VerdocsEnvelopeSidebarCustomEvent<{open: boolean}>) => void;
    }
    /**
     * Displays a list of envelopes matching specified conditions.
     */
    interface VerdocsEnvelopesList {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * If set, filter envelopes by the specified string.
         */
        "match"?: string;
        /**
          * Event fired when the user changes the match filter. This is fired for every inputChange event (every character typed). This event is provided for balance with the other events, but host applications should generally not save this value. Users might appreciate applications remembering their sorting or filtering preferences, but probably not their search terms.
         */
        "onChangeMatch"?: (event: VerdocsEnvelopesListCustomEvent<string>) => void;
        /**
          * Event fired when the user changes their sort order. Host applications can use this to save the user's preferences.
         */
        "onChangeSort"?: (event: VerdocsEnvelopesListCustomEvent<'name' | 'created_at' | 'updated_at' | 'canceled_at' | 'status'>) => void;
        /**
          * Event fired when the user changes their status filter. Host applications can use this to save the user's preferences.
         */
        "onChangeStatus"?: (event: VerdocsEnvelopesListCustomEvent<TEnvelopeStatus | 'all'>) => void;
        /**
          * Event fired when the user changes their view. Host applications can use this to save the user's preferences.
         */
        "onChangeView"?: (event: VerdocsEnvelopesListCustomEvent<'all' | 'inbox' | 'sent' | 'completed' | 'action' | 'waiting'>) => void;
        /**
          * Event fired when the user clicks to finish the envelope.
         */
        "onFinishEnvelope"?: (event: VerdocsEnvelopesListCustomEvent<{endpoint: VerdocsEndpoint; envelope: IEnvelope}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsEnvelopesListCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user clicks an activity entry. Typically the host application will use this to navigate to the envelope detail view.
         */
        "onViewEnvelope"?: (event: VerdocsEnvelopesListCustomEvent<{endpoint: VerdocsEndpoint; envelope: IEnvelope}>) => void;
        /**
          * The number of rows to display per page.
         */
        "rowsPerPage"?: number;
        /**
          * The initial page number to select. Pagination is internally controlled but may be overriden by the host applicaiton.
         */
        "selectedPage"?: number;
        /**
          * Whether or not pagination should be enabled.
         */
        "showPagination"?: boolean;
        /**
          * The sort field to use
         */
        "sort"?: 'name' | 'created_at' | 'updated_at' | 'canceled_at' | 'status';
        /**
          * The status value to filter by
         */
        "status"?: TEnvelopeStatus | 'all';
        /**
          * The filtered view to display. "completed" will show envelopes that have been submitted. "action" will show envelopes where the user is a recipient and the envelope is not completed. "waiting" will show only envelopes where the user is the sender and the envelope is not completed.
         */
        "view"?: 'all' | 'inbox' | 'sent' | 'completed' | 'action' | 'waiting';
    }
    /**
     * Displays an attachment field.
     */
    interface VerdocsFieldAttachment {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used. This component self-manages its resize (width) behavior when in edit-template mode, and uses this endpoint to save changes.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * The name of the field to display.
         */
        "fieldname"?: string;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * Event fired when the field is deleted.
         */
        "onAttached"?: (event: VerdocsFieldAttachmentCustomEvent<ISelectedFile>) => void;
        /**
          * Event fired when the field is deleted.
         */
        "onDeleted"?: (event: VerdocsFieldAttachmentCustomEvent<{fieldName: string}>) => void;
        /**
          * Event fired when the field's settings are changed.
         */
        "onSettingsChanged"?: (event: VerdocsFieldAttachmentCustomEvent<{fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField}>) => void;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid"?: string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a checkbox.
     */
    interface VerdocsFieldCheckbox {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The name of the field to display.
         */
        "fieldname"?: string;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * Event fired when the field is deleted.
         */
        "onDeleted"?: (event: VerdocsFieldCheckboxCustomEvent<{fieldName: string}>) => void;
        /**
          * Event fired when the field's settings are changed.
         */
        "onSettingsChanged"?: (event: VerdocsFieldCheckboxCustomEvent<{fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField}>) => void;
        /**
          * The index of the settings option this particular checkbox is for
         */
        "option"?: number;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid"?: string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a date field. When tapped or clicked, the input element will display a date picker component.
     */
    interface VerdocsFieldDate {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "field"?: ITemplateField;
        /**
          * The name of the field to display.
         */
        "fieldname"?: string;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * Event fired when the field is deleted.
         */
        "onDeleted"?: (event: VerdocsFieldDateCustomEvent<{fieldName: string}>) => void;
        /**
          * Event fired when the field's settings are changed.
         */
        "onSettingsChanged"?: (event: VerdocsFieldDateCustomEvent<{fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField}>) => void;
        /**
          * Event fired on every character entered into / deleted from the field.
         */
        "onSettingsPress"?: (event: VerdocsFieldDateCustomEvent<any>) => void;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        /**
          * The template the field is for/from. Only required for the field builder, passed down to the properties component.
         */
        "templateid"?: string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a dropdown field that allows the user to choose one of a list of options.
     */
    interface VerdocsFieldDropdown {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The name of the field to display.
         */
        "fieldname"?: string;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * Event fired when the field is deleted.
         */
        "onDeleted"?: (event: VerdocsFieldDropdownCustomEvent<{fieldName: string}>) => void;
        /**
          * Event fired when the input field value changes. Note that this will only be fired on blur, tab-out, ENTER key press, etc. It is generally the best event to subscribe to than `input` for most cases EXCEPT autocomplete fields that need to see every keypress.
         */
        "onFieldChange"?: (event: VerdocsFieldDropdownCustomEvent<string>) => void;
        /**
          * Event fired when the field's settings are changed.
         */
        "onSettingsChanged"?: (event: VerdocsFieldDropdownCustomEvent<{fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField}>) => void;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid"?: string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays an initial field. If an initial already exists, it will be displayed and the field
     * will be disabled. Otherwise, a placeholder button will be shown. Clicking the button will
     * show a dialog to adopt an initial.
     * NOTE: When initial fields are completed they will be filled with an initial "stamp".
     * This requires operation against a live, valid envelope. If you are testing this component
     * in Storybook, it will not be visible here.
     */
    interface VerdocsFieldInitial {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The name of the field to display.
         */
        "fieldname"?: string;
        /**
          * The document or template field to display.
         */
        "initials"?: string;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * Event emitted when an initial block is adopted by the user. The event detail will contain the base64 string of the initial image.
         */
        "onAdopt"?: (event: VerdocsFieldInitialCustomEvent<string>) => void;
        /**
          * Event fired when the field is deleted.
         */
        "onDeleted"?: (event: VerdocsFieldInitialCustomEvent<{fieldName: string}>) => void;
        /**
          * Event fired when the step is cancelled. This is called exit to avoid conflicts with the JS-reserved "cancel" event name.
         */
        "onExit"?: (event: VerdocsFieldInitialCustomEvent<any>) => void;
        /**
          * Event fired when the input field value changes. Note that this will only be fired on blur, tab-out, ENTER key press, etc. It is generally the best event to subscribe to than `input` for most cases EXCEPT autocomplete fields that need to see every keypress.
         */
        "onFieldChange"?: (event: VerdocsFieldInitialCustomEvent<string>) => void;
        /**
          * Event fired when the field's settings are changed.
         */
        "onSettingsChanged"?: (event: VerdocsFieldInitialCustomEvent<{fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField}>) => void;
        /**
          * Event fired on every character entered into / deleted from the field.
         */
        "onSettingsPress"?: (event: VerdocsFieldInitialCustomEvent<any>) => void;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid"?: string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a signature field. Various field types are supported, including traditional Signature and Initials types as well as
     * input types like text and checkbox.
     */
    interface VerdocsFieldPayment {
        "currentInitial"?: string;
        "currentInitialId"?: string;
        "currentSignature"?: string;
        "currentSignatureId"?: string;
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        "fieldId"?: string;
        /**
          * The name of the field to display.
         */
        "fieldname"?: string;
        "fields"?: any[];
        "focused"?: boolean;
        /**
          * Event fired when the field is deleted.
         */
        "onDeleted"?: (event: VerdocsFieldPaymentCustomEvent<{fieldName: string}>) => void;
        "onInitialComplete"?: (event: VerdocsFieldPaymentCustomEvent<string>) => void;
        "onSettingsChanged"?: (event: VerdocsFieldPaymentCustomEvent<{fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField}>) => void;
        "onSignatureComplete"?: (event: VerdocsFieldPaymentCustomEvent<string>) => void;
        "pageNum"?: number;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        "pdfPages"?: any[];
        "recipients"?: any;
        "roleName"?: string;
        /**
          * If set, the field will be colored using this index value to select the background color.
         */
        "roleindex"?: number;
        "selectedRoleName"?: string;
        "signed"?: boolean;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid"?: string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a radio button.
     */
    interface VerdocsFieldRadioButton {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The name of the field to display.
         */
        "fieldname"?: string;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * Event fired when the field is deleted.
         */
        "onDeleted"?: (event: VerdocsFieldRadioButtonCustomEvent<{fieldName: string}>) => void;
        /**
          * Event fired when the field's settings are changed.
         */
        "onSettingsChanged"?: (event: VerdocsFieldRadioButtonCustomEvent<{fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField}>) => void;
        /**
          * The index of the settings option this particular checkbox is for
         */
        "option"?: number;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid"?: string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a signature field. If a signature already exists, it will be displayed and the field
     * will be disabled. Otherwise, a placeholder button will be shown. Clicking the button will
     * show a dialog to adopt a signature.
     * NOTE: When signature fields are completed they will be filled with a signature "stamp".
     * This requires operation against a live, valid envelope. If you are testing this component
     * in Storybook, it will not be visible here.
     */
    interface VerdocsFieldSignature {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The name of the field to display.
         */
        "fieldname"?: string;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * If set, the signature creation dialog will be initialized with this text.
         */
        "name"?: string;
        /**
          * Event fired when the field is deleted.
         */
        "onDeleted"?: (event: VerdocsFieldSignatureCustomEvent<{fieldName: string}>) => void;
        /**
          * Event emitted when the field has changed.
         */
        "onFieldChange"?: (event: VerdocsFieldSignatureCustomEvent<string>) => void;
        /**
          * Event fired when the field's settings are changed.
         */
        "onSettingsChanged"?: (event: VerdocsFieldSignatureCustomEvent<{fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField}>) => void;
        /**
          * Event fired on every character entered into / deleted from the field.
         */
        "onSettingsPress"?: (event: VerdocsFieldSignatureCustomEvent<any>) => void;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid"?: string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Display a multi-line text input field. Reminder: the "position" of the field is specified
     * as the BOTTOM-LEFT corner.
     */
    interface VerdocsFieldTextarea {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used. This component self-manages its resize (width) behavior when in edit-template mode, and uses this endpoint to save changes.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * The name of the field to display.
         */
        "fieldname"?: string;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * Event fired when the field is deleted.
         */
        "onDeleted"?: (event: VerdocsFieldTextareaCustomEvent<{fieldName: string}>) => void;
        /**
          * Event fired when the field's settings are changed.
         */
        "onSettingsChanged"?: (event: VerdocsFieldTextareaCustomEvent<{fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField}>) => void;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid"?: string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Display a simple 1-line text input field.
     */
    interface VerdocsFieldTextbox {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used. This component self-manages its resize (width) behavior when in edit-template mode, and uses this endpoint to save changes.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * The name of the field to display.
         */
        "fieldname"?: string;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * Event fired when the field is deleted.
         */
        "onDeleted"?: (event: VerdocsFieldTextboxCustomEvent<{fieldName: string}>) => void;
        /**
          * Event fired when the field's settings are changed.
         */
        "onSettingsChanged"?: (event: VerdocsFieldTextboxCustomEvent<{fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField}>) => void;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid"?: string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Display a timestamp. Timestamps are not editable by signers. Instead, they are automatically
     * filled when the signer submits the document.
     */
    interface VerdocsFieldTimestamp {
        /**
          * If set, overrides the field's settings object. Primarily used to support "preview" modes where all fields are disabled.
         */
        "disabled"?: boolean;
        /**
          * If set, the field is considered "done" and is drawn in a display-final-value state.
         */
        "done"?: boolean;
        /**
          * If set, a settings icon will be displayed on hover. The settings shown allow the field's recipient and other settings to be changed, so it should typically only be enabled in the Builder.
         */
        "editable"?: boolean;
        /**
          * The name of the field to display.
         */
        "fieldname"?: string;
        /**
          * If set, the field may be dragged to a new location. This should only be enabled in the Builder, or for self-placed fields.
         */
        "moveable"?: boolean;
        /**
          * Event fired when the field is deleted.
         */
        "onDeleted"?: (event: VerdocsFieldTimestampCustomEvent<{fieldName: string}>) => void;
        /**
          * Event fired when the field's settings are changed.
         */
        "onSettingsChanged"?: (event: VerdocsFieldTimestampCustomEvent<{fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField}>) => void;
        /**
          * The page the field is on
         */
        "pagenumber"?: number;
        /**
          * The template the field is for/from. Only required in Builder mode, to support the Field Properties dialog.
         */
        "templateid"?: string;
        /**
          * If set, the field will be be scaled horizontally by this factor.
         */
        "xscale"?: number;
        /**
          * If set, the field will be be scaled vertically by this factor.
         */
        "yscale"?: number;
    }
    /**
     * Displays a file picker to upload an attachment. This component is just the picker - the host application or component should
     * provide the actual upload functionality.
     * ```ts
     * <verdocs-file-chooser onFileSelected={(e) => console.log('File Selected', e.detail)} />
     * ```
     */
    interface VerdocsFileChooser {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when a file has been selected. Note that the file may be null if the user is choosing a different file. Host applications should use this event to enable/disable buttons to upload or otherwise process the selected file.
         */
        "onFileSelected"?: (event: VerdocsFileChooserCustomEvent<{file: File | null}>) => void;
    }
    /**
     * Displays a simple help icon. Upon hover or focus, a tooltip will be displayed with help text.
     * ```ts
     * <verdocs-help-icon text="Sample help text" />
     * ```
     */
    interface VerdocsHelpIcon {
        /**
          * Optional icon to display. If not supplied, a standard help icon will be shown.
         */
        "icon"?: string;
        /**
          * Help text to display on hover/focus
         */
        "text"?: string;
    }
    /**
     * Display a dialog that allows the user to specify an initials image, either by using a signature-font-generated image
     * based on their full name, or by hand-drawing their initials with a mouse or tablet.
     */
    interface VerdocsInitialDialog {
        /**
          * Initial signature text
         */
        "initials"?: string;
        /**
          * Event fired when the step is cancelled. This is called exit to avoid conflicts with the JS-reserved "cancel" event name.
         */
        "onExit"?: (event: VerdocsInitialDialogCustomEvent<any>) => void;
        /**
          * Event fired when the initials are adopted.
         */
        "onNext"?: (event: VerdocsInitialDialogCustomEvent<string>) => void;
    }
    /**
     * Prompt the user to confirm their identity with a series of questions.
     */
    interface VerdocsKbaDialog {
        /**
          * For choice challenges, a set of choices to choose from. 6 choices is recommended to fit most screen sizes.
         */
        "choices"?: string[];
        /**
          * If set, a help/instructions box will be displayed with this text
         */
        "helptext"?: string;
        /**
          * If set, a help/instructions box will be displayed with this title
         */
        "helptitle"?: string;
        /**
          * For text input challenges, the label to display next to the input field.
         */
        "label"?: string;
        /**
          * Whether the dialog is currently being displayed. This allows it to be added to the DOM before being displayed.
         */
        "mode"?: 'text' | 'choice';
        /**
          * Event fired when the step is cancelled. This is called exit to avoid conflicts with the JS-reserved "cancel" event name.
         */
        "onExit"?: (event: VerdocsKbaDialogCustomEvent<any>) => void;
        /**
          * Event fired when the dialog is closed. The event data will contain the value selected.
         */
        "onNext"?: (event: VerdocsKbaDialogCustomEvent<string>) => void;
        /**
          * For text input challenges, the placeholder to display inside the input field.
         */
        "placeholder"?: string;
        /**
          * Which step this confirmation is for, in a multi-step process. Ignored if `steps` is < 2.
         */
        "step"?: number;
        /**
          * How many steps exist in a multi-step process. Set to 1 for a single-step process (hides the indicator).
         */
        "steps"?: number;
    }
    /**
     * Animated loader placeholder. There are currently no configuration options for this control.
     * ```ts
     * <verdocs-loader />
     * ```
     */
    interface VerdocsLoader {
    }
    /**
     * Display a simple text dialog box with an Ok button. This adds a partially-transparent overlay and screen-centered dialog
     * box with a message and optional header/title. An OK button is shown that will dismiss the message.
     * It can also be dismissed by clicking the background overlay.
     */
    interface VerdocsOkDialog {
        /**
          * Override the "OK" button's label
         */
        "buttonLabel"?: string;
        /**
          * The title of the dialog. "title" is a reserved word, so we use heading.
         */
        "heading"?: string;
        /**
          * The message content to display.
         */
        "message"?: string;
        /**
          * Event fired when the step is cancelled. This is called exit to avoid conflicts with the JS-reserved "cancel" event name.
         */
        "onExit"?: (event: VerdocsOkDialogCustomEvent<any>) => void;
        /**
          * Event fired when the user clicks the OK button.
         */
        "onNext"?: (event: VerdocsOkDialogCustomEvent<any>) => void;
        /**
          * If set, a cancel button will also be displayed. Note that the dialog is always cancelable by clicking the background overlay to dismiss it.
         */
        "showCancel"?: boolean;
    }
    /**
     * Display a small summary card describing an organization.
     * ```ts
     * <verdocs-organization-card organization={organization} />
     * ```
     */
    interface VerdocsOrganizationCard {
        /**
          * The organization to display
         */
        "organization"?: IOrganization;
    }
    /**
     * Display a simple pagination control with individual buttons to move through the data set.
     * ```ts
     * <verdocs-pagination
     *   selectedPage={1}
     *   itemCount={50}
     *   perPage={10}
     *   onSelectPage={(e) => {setSelectedpage(e.detail.selectedPage)}}
     * />
     * ```
     */
    interface VerdocsPagination {
        /**
          * The total number of items.
         */
        "itemCount"?: number;
        /**
          * Event fired when the selected page changes. The new page number is included in the event.
         */
        "onSelectPage"?: (event: VerdocsPaginationCustomEvent<{selectedPage: number}>) => void;
        /**
          * The number of displayed per page.
         */
        "perPage"?: number;
        /**
          * The currently selected page.
         */
        "selectedPage"?: number;
    }
    /**
     * Display a child component in a "portal", popping it out of the main DOM tree
     * to allow it to escape the bounds set by its parent.
     * @credit https://github.com/tomas-teston/stencil-portal for the basic
     * technique. This has been altered in a few ways to make it more friendly
     * to cases where there may be multiple portals on the page and provide more
     * alignment options for the child to be displayed.
     * ```ts
     * <div style="padding: 40px">
     * <div id="sample-tooltip" style="border: 1px solid green; padding: 3px 10px;">
     * Tooltip Anchor
     * <verdocs-portal anchor="sample-tooltip" .align=${align} .voffset=${voffset}>
     * <div style="border: 1px solid red; padding: 3px 10px;">Tooltip</div>
     * </verdocs-portal>
     * </div>
     * </div>
     * ```
     */
    interface VerdocsPortal {
        /**
          * Horizontal alignment.
         */
        "align"?: 'left' | 'center' | 'right';
        /**
          * Unique ID of the parent element to anchor to.
         */
        "anchor"?: string;
        "onClickAway"?: (event: VerdocsPortalCustomEvent<void>) => void;
        /**
          * Vertical offset from the parent.
         */
        "voffset"?: number;
    }
    /**
     * Display a template preview experience. This will display the template's attached
     * documents with signing fields overlaid on each page. Fields will be color-coded
     * by recipient, and will be read-only (cannot be filled, moved, or altered).
     * ```ts
     * <verdocs-preview templateId={templateId} />
     * ```
     */
    interface VerdocsPreview {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsPreviewCustomEvent<SDKError>) => void;
        /**
          * The ID of the template to create the document from.
         */
        "templateId"?: string | null;
    }
    /**
     * Display a simple progress bar in a style consistent with the design system.
     * ```ts
     * <verdocs-progress-bar label="Uploading..." showPercent={true} percent={54} />
     * ```
     */
    interface VerdocsProgressBar {
        /**
          * Optional label to display above the bar
         */
        "label"?: string;
        /**
          * The current progress value (0-100)
         */
        "percent"?: number;
        /**
          * If true, the progress percentage will be displayed above the bar.
         */
        "showPercent"?: boolean;
    }
    /**
     * Display a drop-down menu of quick filter options.
     * ```ts
     * <verdocs-quick-filter options={[...options]} value={1} label="Filter" placeholder="All" />
     * ```
     */
    interface VerdocsQuickFilter {
        "label"?: string;
        /**
          * Event fired when a menu option is clicked. Web Component events need to be "composed" to cross the Shadow DOM and be received by parent frameworks.
         */
        "onOptionSelected"?: (event: VerdocsQuickFilterCustomEvent<IFilterOption>) => void;
        /**
          * The menu options to display.
         */
        "options"?: IFilterOption[];
        "placeholder"?: string;
        "value"?: string;
    }
    /**
     * Display quick-function buttons for creating templates and documents.
     * Authentication is required to demonstrate this Element. You may do this in Storybook by using the Auth
     * embed. This Element will reuse the same session produced by logging in via that Embed.
     */
    interface VerdocsQuickFunctions {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when an entry is clicked.
         */
        "onCreateDocument"?: (event: VerdocsQuickFunctionsCustomEvent<any>) => void;
        /**
          * Event fired when an entry is clicked.
         */
        "onCreateTemplate"?: (event: VerdocsQuickFunctionsCustomEvent<any>) => void;
    }
    /**
     * Displays a radio button. Note that this is different from the `verdocs-field-radio-button` component, which is
     * designed to be used in signing experiences and contains settings that connect to template fields. This is just a
     * simple radio button for UI displays e.g. dialog boxes.
     * This control encapsulates a standard HTML radio button. To subscribe to change events, connect an `onChange`
     * handler. Sample usage:
     * ```ts
     * <verdocs-radio-button
     *    value="val1"
     *    name="someProperty"
     *    checked={this.someProperty === 'val1'}
     *    onInput={(e: any) => { this.someProperty = 'val1' }}
     *    disabled={false}
     * />
     * ```
     */
    interface VerdocsRadioButton {
        /**
          * Whether the radio button is currently selected.
         */
        "checked"?: boolean;
        /**
          * If set, the button will still be displayed but not selectable.
         */
        "disabled"?: boolean;
        /**
          * HTML form field name for the input.
         */
        "name"?: string;
        /**
          * Value to track with the input.
         */
        "value"?: string;
    }
    interface VerdocsSearch {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
    }
    /**
     * Displays a customizable input box for search queries.
     * Authentication is required to demonstrate this Element. You may do this in Storybook by using the Auth
     * embed. This Element will reuse the same session produced by logging in via that Embed.
     */
    interface VerdocsSearchBox {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * If set, the input field will attempt to "grab" focus after being rendered.
         */
        "grabsFocus"?: boolean;
        /**
          * Event fired when the user changes the query string.
         */
        "onQueryChanged"?: (event: VerdocsSearchBoxCustomEvent<string>) => void;
        /**
          * Event fired when the user changes the type.
         */
        "onSearchClicked"?: (event: VerdocsSearchBoxCustomEvent<ISearchEvent>) => void;
        /**
          * Event fired when the user changes the type.
         */
        "onTypeChanged"?: (event: VerdocsSearchBoxCustomEvent<TContentType>) => void;
        /**
          * The placeholder to display in the input field.
         */
        "placeholder"?: string;
        /**
          * The text search string entered by the user.
         */
        "query"?: string;
        /**
          * If set to a value other than 'all', a removeable filter indicator will be displayed.
         */
        "type"?: TContentType;
    }
    interface VerdocsSearchTabs {
    }
    /**
     * Display a text input field. This is just a standard HTML input field with minimal markup to fit the
     * visual styles of the other components. Note that events "bubble" from the input field to the container,
     * so you can subscribe to the same DOM events (input, blur, etc) that a normal input would emit.
     * ```ts
     * <verdocs-select-input label="Select:" label="Select" options={[...options]}
     * @input ={() => {}} />
     * ```
     */
    interface VerdocsSelectInput {
        /**
          * Should the field be disabled?
         */
        "disabled"?: boolean;
        /**
          * The label for the field.
         */
        "label"?: string;
        /**
          * The options to list.
         */
        "options"?: {label: string; value: string}[];
        /**
          * The initial value for the input field.
         */
        "value"?: string;
    }
    /**
     * Display a form to send a template to one or more recipients in an envelope for signing. Note
     * that because most applications have custom workflow requirements to trigger after sending an
     * Envelope, this component does not actually perform that operation. Parent applications should
     * listen for the `onSend` event, and can pass the contents of `event.detail` directly to the
     * `createEnvelope()` call in JS-SDK.
     * Host applications should ensure the template is "sendable" before displaying this component.
     * To be sendable, a template must have at least one document attached, at least one participant
     * defined, and at least one field assigned to every "signer" participant. This component will
     * hide itself if the template is not sendable.
     * ```ts
     * <verdocs-send templateId={templateId} />
     * ```
     */
    interface VerdocsSend {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * The environment the control is being called from, e.g. 'web'. This has an impact on how certain operations such as email communications are handled to ensure users receive the correct URLs for their invitations. Setting this to unknown values may produce unexpected/incorrect behaviors. If environment is not known, do this set this property.
         */
        "environment"?: string;
        /**
          * Event fired when the step is cancelled. This is called exit to avoid conflicts with the JS-reserved "cancel" event name.
         */
        "onExit"?: (event: VerdocsSendCustomEvent<any>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsSendCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user enters text in a search field. The parent application may use this to update the `contactSuggestions` property.
         */
        "onSearchContacts"?: (event: VerdocsSendCustomEvent<IContactSearchEvent1>) => void;
        /**
          * The user completed the form and clicked send.
         */
        "onSend"?: (event: VerdocsSendCustomEvent<{roles: ICreateEnvelopeRole[]; name: string; template_id: string; envelope_id: string; envelope: IEnvelope}>) => void;
        /**
          * The user is sending an envelope the form and clicked send.
         */
        "onSendingEnvelope"?: (event: VerdocsSendCustomEvent<{sending: boolean}>) => void;
        /**
          * The ID of the template to create the document from.
         */
        "templateId"?: string | null;
    }
    /**
     * Display a template preview experience. This will display the template's attached
     * documents with signing fields overlaid on each page. Fields will be color-coded
     * by recipient, and will be read-only (cannot be filled, moved, or altered).
     * ```ts
     * <verdocs-settings />
     * ```
     */
    interface VerdocsSettings {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsSettingsCustomEvent<SDKError>) => void;
    }
    /**
     * Displays a settings form that allows the user to manage their API keys.
     */
    interface VerdocsSettingsApiKeys {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the user chooses to invite a new member.
         */
        "onMemberInvited"?: (event: VerdocsSettingsApiKeysCustomEvent<{endpoint: VerdocsEndpoint; member: IProfile}>) => void;
        /**
          * Event fired when the user chooses to invite a new member.
         */
        "onMemberRemoved"?: (event: VerdocsSettingsApiKeysCustomEvent<{endpoint: VerdocsEndpoint; member: IProfile}>) => void;
        /**
          * Event fired when the user chooses to invite a new member.
         */
        "onMemberUpdated"?: (event: VerdocsSettingsApiKeysCustomEvent<{endpoint: VerdocsEndpoint; member: IProfile}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsSettingsApiKeysCustomEvent<SDKError>) => void;
    }
    /**
     * Displays a settings form that allows the user to manage their Verdocs profile.
     */
    interface VerdocsSettingsMembers {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the user chooses to invite a new member.
         */
        "onMemberInvited"?: (event: VerdocsSettingsMembersCustomEvent<{endpoint: VerdocsEndpoint; member: IProfile}>) => void;
        /**
          * Event fired when the user chooses to invite a new member.
         */
        "onMemberRemoved"?: (event: VerdocsSettingsMembersCustomEvent<{endpoint: VerdocsEndpoint; member: IProfile}>) => void;
        /**
          * Event fired when the user chooses to invite a new member.
         */
        "onMemberUpdated"?: (event: VerdocsSettingsMembersCustomEvent<{endpoint: VerdocsEndpoint; member: IProfile}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsSettingsMembersCustomEvent<SDKError>) => void;
    }
    /**
     * Displays a settings form that allows the user to manage their Verdocs profile.
     */
    interface VerdocsSettingsOrganization {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the user chooses the Edit option from the dropdown menu.
         */
        "onOrganizationUpdated"?: (event: VerdocsSettingsOrganizationCustomEvent<{endpoint: VerdocsEndpoint; organization: IOrganization}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsSettingsOrganizationCustomEvent<SDKError>) => void;
    }
    /**
     * Displays a settings form that allows the user to manage their Verdocs profile.
     */
    interface VerdocsSettingsProfile {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the user chooses the Edit option from the dropdown menu.
         */
        "onProfileUpdated"?: (event: VerdocsSettingsProfileCustomEvent<{endpoint: VerdocsEndpoint; profile: IProfile}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsSettingsProfileCustomEvent<SDKError>) => void;
    }
    /**
     * Display an envelope signing experience. This will display the envelope's attached
     * documents with signing fields overlaid on each page.
     * The component will attempt to initiate a signing session and load the specified
     * envelope. If successful, the recipient's fields will be enabled and the user will
     * be able to sign the envelope's attached documents. If not, an `sdkError` will be
     * thrown and the component will be blank/empty. To provide the best user experience,
     * applications should capture and handle this error to provide the user with
     * instructions/options for next steps based on the application's design and workflow.
     * Unlike other components, this will always create its own endpoint to manage the
     * session session. This endpoint will be included in event callbacks for the
     * convenience of host applications that may wish to make server calls using the
     * signer's credentials once signing is complete (e.g. to obtain copies of
     * the signed attachments.)
     */
    interface VerdocsSign {
        /**
          * The ID of the envelope to sign.
         */
        "envelopeId"?: string | null;
        /**
          * If set, (recommended), the host application should create a <DIV> element with a unique ID. When this component renders, the header will be removed from its default location and placed in the target element. This allows the parent application to more easily control its placement and scroll effects (e.g. "fixed").  The movement of the header to the target container is not dynamic - it is performed only on the initial render. Host applications should not conditionally render this container. If the header's visibility must be externally controlled, use CSS display options to hide/show it instead.
         */
        "headerTargetId"?: string | null;
        /**
          * The invite code for the signer.
         */
        "inviteCode"?: string | null;
        /**
          * Event fired when the envelope is updated in any way.
         */
        "onEnvelopeLoaded"?: (event: VerdocsSignCustomEvent<{endpoint: VerdocsEndpoint; envelope: IEnvelope}>) => void;
        /**
          * Event fired when the envelope is updated in any way. May be used for tasks such as cache invalidation or reporting to other systems.
         */
        "onEnvelopeUpdated"?: (event: VerdocsSignCustomEvent<{endpoint: VerdocsEndpoint; envelope: IEnvelope; event: string}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsSignCustomEvent<SDKError>) => void;
        /**
          * The ID of the role that will be signing e.g. 'Recipient 1'
         */
        "roleId"?: string | null;
    }
    /**
     * Display a dialog that allows the user to specify a signature image, either by using a signature-font-generated image
     * based on their full name, or by hand-drawing their signature with a mouse or tablet.
     */
    interface VerdocsSignatureDialog {
        /**
          * Initial signature text
         */
        "name"?: string;
        /**
          * Event fired when the step is cancelled. This is called exit to avoid conflicts with the JS-reserved "cancel" event name.
         */
        "onExit"?: (event: VerdocsSignatureDialogCustomEvent<any>) => void;
        /**
          * Fired when the user completes the dialog and clicks Adopt. The event detail will contain a base64-encoded string representation of the signature adopted.
         */
        "onNext"?: (event: VerdocsSignatureDialogCustomEvent<string>) => void;
    }
    /**
     * Display a small loading spinner.
     * ```ts
     * <verdocs-spinner />
     * ```
     */
    interface VerdocsSpinner {
        "mode"?: 'light' | 'dark';
        "size"?: number;
    }
    /**
     * Displays an icon and message describing a document's completion status. For convenience, the status may be passed in either
     * directly as a status field or the whole document object may be passed in.
     * If the document is provided, the status flag will indicate the document's overall status. This also makes the component clickable
     * to display a popup panel with per-recipient status data.
     * If the status is provided as a string it can be either a `TRecipientStatus` or `TDocumentStatus` value.
     */
    interface VerdocsStatusIndicator {
        /**
          * The document to display status for. Ignored if `status` is set directly.
         */
        "envelope"?: IEnvelope | IEnvelopeSummary;
        /**
          * The size (height) of the indicator. The small variant is suitable for use in densely populated components such as table rows.
         */
        "size"?: 'small' | 'normal';
        /**
          * The status to display.
         */
        "status"?: TEnvelopeStatus | TRecipientStatus | 'accepted';
        /**
          * The theme to use for diplay.
         */
        "theme"?: 'dark' | 'light';
    }
    /**
     * Display a simple table of data. Columns and data cells may have custom renderers defined to
     * support creating interactive table layouts.
     * ```ts
     * <verdocs-table columns={[...columns]} data={[...data]} />
     * ```
     */
    interface VerdocsTable {
        /**
          * The columns to display
         */
        "columns"?: IColumn[];
        /**
          * The rows to display
         */
        "data"?: any[];
        /**
          * Event fired when the user clicks a column header. This may be used to manage sorting options.
         */
        "onColHeaderClick"?: (event: VerdocsTableCustomEvent<{col: IColumn}>) => void;
        /**
          * Event fired when the user clicks a row.
         */
        "onRowClick"?: (event: VerdocsTableCustomEvent<{row: any}>) => void;
    }
    /**
     * Display a simple row of selectable tabs. This is a controlled element.
     * The parent must adjust selectedTab as selection events are fired.
     * ```ts
     * <verdocs-tabs tabs={[...tabs]} />
     * ```
     */
    interface VerdocsTabs {
        /**
          * Event fired when the user clicks a template to view it. Typically the host application will use this to navigate to the template preview. This is also fired when the user selects "Preview/Send" fropm the dropdown menu.
         */
        "onSelectTab"?: (event: VerdocsTabsCustomEvent<{tab: ITab; index: number}>) => void;
        /**
          * The index of the tab to show selected.
         */
        "selectedTab"?: number;
        /**
          * The tabs to display
         */
        "tabs"?: ITab[];
    }
    /**
     * Displays an edit form that allows the user to view, add, or remove a template's attachments.
     * Note that an active session and valid template ID must be supplied.
     */
    interface VerdocsTemplateAttachments {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the step is cancelled. This is called exit to avoid conflicts with the JS-reserved "cancel" event name.
         */
        "onExit"?: (event: VerdocsTemplateAttachmentsCustomEvent<any>) => void;
        /**
          * Event fired when the user clicks the next button.
         */
        "onNext"?: (event: VerdocsTemplateAttachmentsCustomEvent<{template: ITemplate}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplateAttachmentsCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user updates the template.
         */
        "onTemplateUpdated"?: (event: VerdocsTemplateAttachmentsCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate; event: string}>) => void;
        /**
          * The template ID to edit.
         */
        "templateId"?: string;
    }
    /**
     * Display a set of tabs for the template builder.
     */
    interface VerdocsTemplateBuildTabs {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplateBuildTabsCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user selects a different step.
         */
        "onStepChanged"?: (event: VerdocsTemplateBuildTabsCustomEvent<TVerdocsBuildStep1>) => void;
        /**
          * The step in the creation process to display.
         */
        "step"?: TVerdocsBuildStep1;
        /**
          * The ID of the template to create the document from. Unlike most other components, this is an optional parameter here. If the template ID is known, `step` may also be specified to force displaying a specific step in the creation process. If it is not specified, `step` will be ignored and the create step will be shown.
         */
        "templateId"?: string | null;
    }
    /**
     * Displays a summary of a template
     */
    interface VerdocsTemplateCard {
        /**
          * The template for which the card will be rendered.
         */
        "template"?: ITemplate;
    }
    /**
     * Displays a file upload mechanism suitable for the first step of creating a template.
     * This is typically the first step in a template creation workflow.
     */
    interface VerdocsTemplateCreate {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the step is cancelled. This is called exit to avoid conflicts with the JS-reserved "cancel" event name.
         */
        "onExit"?: (event: VerdocsTemplateCreateCustomEvent<any>) => void;
        /**
          * Event fired when the user changes the type.
         */
        "onNext"?: (event: VerdocsTemplateCreateCustomEvent<ITemplate>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplateCreateCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user updates the template.
         */
        "onTemplateCreated"?: (event: VerdocsTemplateCreateCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate; templateId: string}>) => void;
    }
    /**
     * Represents one document page. This is primarily a layout container used to coordinate positions of
     * page-related layers such as the page itself, signature fields, etc. It is not intended to be used
     * on its own as an individual component.
     */
    interface VerdocsTemplateDocumentPage {
        /**
          * Whether the fields should be disabled (Builder)
         */
        "disabled"?: boolean;
        /**
          * The ID of the document to display.
         */
        "documentId"?: string;
        /**
          * Whether the field are interactable (done/submitted disables this)
         */
        "done"?: boolean;
        /**
          * Whether the fields should be editable (Builder)
         */
        "editable"?: boolean;
        /**
          * The endpoint to load from.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * The layers that will be rendered. The DOM structure will be a DIV container with one child DIV for each layer. The parent DIV will have a unique ID, and each child DIV will have that ID with the layer name appended, e.g. if `pages` was ['page', 'fields'] the structure will be:  ```     <div id="verdocs-document-page-ker2fr1p9">       <div id="verdocs-document-page-ker2fr1p9-page"></div>       <div id="verdocs-document-page-ker2fr1p9-fields"></div>     </div> ```
         */
        "layers"?: IPageLayer[];
        /**
          * Fired when a page has been rendered. This is also fired when the page is resized.
         */
        "onPageRendered"?: (event: VerdocsTemplateDocumentPageCustomEvent<IDocumentPageInfo>) => void;
        /**
          * The page number being rendered. (Reminder: page numbers are 1-based.)
         */
        "pageNumber"?: number;
        /**
          * The ID of the template the document is for.
         */
        "templateId"?: string;
        /**
          * The "virtual" height of the page canvas.  Defaults to 792 which at 72dpi is 11" tall. This is used to compute the aspect ratio of the final rendered element when scaling up/down.
         */
        "virtualHeight"?: number;
        /**
          * The "virtual" width of the page canvas. Defaults to 612 which at 72dpi is 8.5" wide. This is used to compute the aspect ratio of the final rendered element when scaling up/down.
         */
        "virtualWidth"?: number;
    }
    /**
     * Displays an edit form that allows the user to adjust a field's settings.
     */
    interface VerdocsTemplateFieldProperties {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * The field to configure.
         */
        "fieldName"?: string;
        /**
          * If specified, the properties card will have a "back" side with the help text as its content.
         */
        "helpText"?: string;
        /**
          * Event fired when the user cancels the dialog.
         */
        "onClose"?: (event: VerdocsTemplateFieldPropertiesCustomEvent<any>) => void;
        /**
          * Event fired when the user deletes the role. The parent should update its UI to reflect the removal. When this event is emitted, the role will have already been deleted server-side.
         */
        "onDelete"?: (event: VerdocsTemplateFieldPropertiesCustomEvent<{templateId: string; roleName: string}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplateFieldPropertiesCustomEvent<SDKError>) => void;
        /**
          * Event fired when the field's settings are changed.
         */
        "onSettingsChanged"?: (event: VerdocsTemplateFieldPropertiesCustomEvent<{fieldName: string; settings: ITemplateFieldSetting; field: ITemplateField}>) => void;
        /**
          * The template ID to edit.
         */
        "templateId"?: string;
    }
    /**
     * Displays a builder experience for laying out fields in a template. Note that this experience requires a large display area to
     * present all of the required controls, so it is primarily intended to be used in desktop environments.
     */
    interface VerdocsTemplateFields {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        "onFieldsUpdated"?: (event: VerdocsTemplateFieldsCustomEvent<{endpoint: VerdocsEndpoint; templateId: string; event: 'added' | 'deleted' | 'updated'; fields: ITemplateField[]}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplateFieldsCustomEvent<SDKError>) => void;
        /**
          * Event fired when the template is updated in any way. May be used for tasks such as cache invalidation or reporting to other systems.
         */
        "onTemplateUpdated"?: (event: VerdocsTemplateFieldsCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate; event: string}>) => void;
        /**
          * The ID of the template to create the document from.
         */
        "templateId"?: string | null;
        /**
          * If set, (recommended), the host application should create a <DIV> element with a unique ID. When this component renders, the toolbar will be removed from its default location and placed in the target element. This allows the parent application to more easily control its placement and scroll effects.  The movement of the toolbar to the target container is not dynamic - it is performed only on the initial render. Host applications should not conditionally render this container. If the toolbar's visibility must be externally controlled, use CSS display options to hide/show it instead.
         */
        "toolbarTargetId"?: string | null;
    }
    /**
     * Displays an edit form that allows the user to rename a template. Note that an active session and valid template ID must be supplied.
     */
    interface VerdocsTemplateName {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the user cancels the dialog.
         */
        "onClose"?: (event: VerdocsTemplateNameCustomEvent<any>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplateNameCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user updates the template.
         */
        "onTemplateUpdated"?: (event: VerdocsTemplateNameCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate; event: string}>) => void;
        /**
          * The template ID to edit.
         */
        "templateId"?: string;
    }
    /**
     * Displays an edit form that allows the user to adjust a template's reminders.
     */
    interface VerdocsTemplateReminders {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the user cancels the dialog.
         */
        "onClose"?: (event: VerdocsTemplateRemindersCustomEvent<any>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplateRemindersCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user updates the template.
         */
        "onTemplateUpdated"?: (event: VerdocsTemplateRemindersCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate; event: string}>) => void;
        /**
          * The template ID to edit.
         */
        "templateId"?: string;
    }
    /**
     * Display an edit form that allows the user to adjust a role's setitngs.
     */
    interface VerdocsTemplateRoleProperties {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the user cancels the dialog.
         */
        "onClose"?: (event: VerdocsTemplateRolePropertiesCustomEvent<any>) => void;
        /**
          * Event fired when the user deletes the role. The parent should update its UI to reflect the removal. When this event is emitted, the role will have already been deleted server-side.
         */
        "onDelete"?: (event: VerdocsTemplateRolePropertiesCustomEvent<{templateId: string; roleName: string}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplateRolePropertiesCustomEvent<SDKError>) => void;
        /**
          * The role name to edit.
         */
        "roleName"?: string;
        /**
          * Whether the dialog is currently being displayed. This allows it to be added to the DOM before being displayed.
         */
        "sender"?: TTemplateSenderType;
        /**
          * The template ID to edit.
         */
        "templateId"?: string;
    }
    /**
     * Displays an edit form that allows the user to adjust a template's roles and workflow.
     */
    interface VerdocsTemplateRoles {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the step is cancelled. This is called exit to avoid conflicts with the JS-reserved "cancel" event name.
         */
        "onExit"?: (event: VerdocsTemplateRolesCustomEvent<any>) => void;
        /**
          * Event fired when the user clicks to proceed.
         */
        "onNext"?: (event: VerdocsTemplateRolesCustomEvent<any>) => void;
        /**
          * Event fired when the template is updated in any way. May be used for tasks such as cache invalidation or reporting to other systems.
         */
        "onRolesUpdated"?: (event: VerdocsTemplateRolesCustomEvent<{endpoint: VerdocsEndpoint; templateId: string; event: 'added' | 'deleted' | 'updated'; roles: IRole[]}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplateRolesCustomEvent<SDKError>) => void;
        /**
          * The template ID to edit.
         */
        "templateId"?: string;
    }
    /**
     * Display a dialog that allows a template sender to be selected.
     */
    interface VerdocsTemplateSender {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the user cancels the dialog.
         */
        "onClose"?: (event: VerdocsTemplateSenderCustomEvent<any>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplateSenderCustomEvent<SDKError>) => void;
        /**
          * Whether the dialog is currently being displayed. This allows it to be added to the DOM before being displayed.
         */
        "sender"?: TTemplateSenderType;
        /**
          * The template ID to edit.
         */
        "templateId"?: string;
    }
    /**
     * Displays a clickable star that allows users to mark frequently-used templates.
     */
    interface VerdocsTemplateStar {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplateStarCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user toggles the star on or off. The event detail will contain the new "starred" status and count.
         */
        "onStarChange"?: (event: VerdocsTemplateStarCustomEvent<{templateId: string; starred: boolean; count: number}>) => void;
        /**
          * The template to display the star for.
         */
        "template"?: ITemplate;
    }
    /**
     * Displays a message listing a template's tags.
     */
    interface VerdocsTemplateTags {
        /**
          * The tags to display
         */
        "tags"?: any[];
    }
    /**
     * Displays an edit form that allows the user to adjust a template's visibility.
     */
    interface VerdocsTemplateVisibility {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * Event fired when the user cancels the dialog.
         */
        "onClose"?: (event: VerdocsTemplateVisibilityCustomEvent<any>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplateVisibilityCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user updates the template.
         */
        "onTemplateUpdated"?: (event: VerdocsTemplateVisibilityCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate; event: string}>) => void;
        /**
          * The template ID to edit.
         */
        "templateId"?: string;
    }
    /**
     * Displays a list of envelopes matching specified conditions.
     */
    interface VerdocsTemplatesList {
        /**
          * Override the If set, filter templates by the specified name.
         */
        "allowedActions"?: TAllowedTemplateAction[];
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * If set, filter templates by the specified name.
         */
        "name"?: string;
        /**
          * Event fired when the user changes the name filter. This is fired for every inputChange event (every character typed). This event is provided for balance with the other events, but host applications should generally not save this value. Users might appreciate applications remembering their sorting or filtering preferences, but probably not their search terms.
         */
        "onChangeName"?: (event: VerdocsTemplatesListCustomEvent<string>) => void;
        /**
          * Event fired when the user changes their sort order. Host applications can use this to save the user's preferences.
         */
        "onChangeSharing"?: (event: VerdocsTemplatesListCustomEvent<'all' | 'personal' | 'shared' | 'public'>) => void;
        /**
          * Event fired when the user changes their sort order. Host applications can use this to save the user's preferences.
         */
        "onChangeSort"?: (event: VerdocsTemplatesListCustomEvent<IGetTemplateSummarySortBy>) => void;
        /**
          * Event fired when the user changes their sort order. Host applications can use this to save the user's preferences.
         */
        "onChangeStarred"?: (event: VerdocsTemplatesListCustomEvent<'all' | 'starred' | 'unstarred'>) => void;
        /**
          * Event fired when the user chooses the Edit option from the dropdown menu.
         */
        "onEditTemplate"?: (event: VerdocsTemplatesListCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate}>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsTemplatesListCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user clicks to sign a template now.
         */
        "onSignNow"?: (event: VerdocsTemplatesListCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate}>) => void;
        /**
          * Event fired when the user clicks to sign a template now.
         */
        "onSubmittedData"?: (event: VerdocsTemplatesListCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate}>) => void;
        /**
          * Event fired when the user chooses the Delete option from the dropdown menu. When this is fired, the template will already have been deleted. The host application should remove it from the list or refresh the list.
         */
        "onTemplateDeleted"?: (event: VerdocsTemplatesListCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate}>) => void;
        /**
          * Event fired when the user clicks a template to view it. Typically the host application will use this to navigate to the template preview. This is also fired when the user selects "Preview/Send" fropm the dropdown menu.
         */
        "onViewTemplate"?: (event: VerdocsTemplatesListCustomEvent<{endpoint: VerdocsEndpoint; template: ITemplate}>) => void;
        /**
          * The number of rows to display per page.
         */
        "rowsPerPage"?: number;
        /**
          * The initial page number to select. Pagination is internally controlled but may be overriden by the host applicaiton.
         */
        "selectedPage"?: number;
        /**
          * The sharing settings to filter by.
         */
        "sharing"?: 'all' | 'personal' | 'shared' | 'public';
        /**
          * Whether or not pagination should be enabled.
         */
        "showPagination"?: boolean;
        /**
          * The sort order to display.
         */
        "sort"?: IGetTemplateSummarySortBy;
        /**
          * The starred settings to filter by.
         */
        "starred"?: 'all' | 'starred' | 'unstarred';
    }
    /**
     * Display a text input field. This is just a standard HTML input field with minimal markup to fit the
     * visual styles of the other components. Note that events "bubble" from the input field to the container,
     * so you can subscribe to the same DOM events (input, blur, etc) that a normal input would emit.
     * ```ts
     * <verdocs-text-input type="text" label="Name" placeholder="Enter your name..." value="" />
     * ```
     */
    interface VerdocsTextInput {
        /**
          * If desired, the autocomplete attribute to set.
         */
        "autocomplete"?: string;
        /**
          * If set, a clear button will be displayed.
         */
        "clearable"?: boolean;
        /**
          * If set, a copy-to-clipboard button will be displayed. NOTE: A field may not be both clearable and copyable. If both properties are set to true, copyable will be ignored.
         */
        "copyable"?: boolean;
        /**
          * Should the field be disabled?
         */
        "disabled"?: boolean;
        /**
          * If supplied, a help icon will be displayed to provide the user more information.
         */
        "helpText"?: string;
        /**
          * The label for the field.
         */
        "label"?: string;
        /**
          * The placeholder for the field.
         */
        "placeholder"?: string;
        /**
          * Should the field be required?
         */
        "required"?: boolean;
        /**
          * The type of field to render. Only text-type fields are allowed here for the current styling. Additional types (e.g. a date picker) will be supported by other controls in the future.
         */
        "type"?: 'text' | 'password' | 'email' | 'number' | 'search' | 'tel' | 'url';
        /**
          * The initial value for the input field.
         */
        "value"?: string;
    }
    /**
     * Displays a label and a set of buttons, also allowing a default selection of a button.
     * ```ts
     * <verdocs-toggle options={[...options]} theme="light"></verdocs-toggle>
     * ```
     */
    interface VerdocsToggle {
        /**
          * The tags to display
         */
        "options"?: IToggleIconButtons;
        /**
          * The "theme" to be used
         */
        "theme"?: 'light' | 'dark';
    }
    /**
     * Displays a single button that can be toggled on or off by clicking it.
     * ```ts
     * <verdocs-toggle-button icon={MessageIcon} size="normal" active={true} />
     * ```
     */
    interface VerdocsToggleButton {
        "active"?: boolean;
        /**
          * If set, should be an SVG object. This will be rendered as the button's visible element. If icon is supplied, label is ignored.
         */
        "icon"?: string | null;
        /**
          * If set, should be an SVG object. This will be rendered as the button's visible element. If icon is supplied, label is ignored.
         */
        "label"?: string | null;
        /**
          * Event fired when the button is pressed.
         */
        "onToggle"?: (event: VerdocsToggleButtonCustomEvent<{active: boolean}>) => void;
        /**
          * How large the button should be. Small buttons are intended for dialog boxes and other smaller scale UI regions.
         */
        "size"?: 'small' | 'normal';
    }
    /**
     * Displays a simple help icon. Upon hover or focus, a tooltip will be displayed with help text.
     * ```ts
     * <verdocs-toolbar-icon text="Sample tooltip text" icon={CalendarIcon} />
     * ```
     */
    interface VerdocsToolbarIcon {
        /**
          * SVG icon to display
         */
        "icon"?: string;
        /**
          * Override the Popper "placement" setting
         */
        "placement"?: Placement;
        /**
          * Help text to display on hover/focus
         */
        "text"?: string;
    }
    /**
     * Display a file upload tool. Note that the file is not actually transmitted, so it may be used by
     * callers with a variety of workflows. Instead, data about the chosen file will be passed to the
     * caller via the onNext event handler.
     */
    interface VerdocsUploadDialog {
        /**
          * Event fired when the step is cancelled. This is called exit to avoid conflicts with the JS-reserved "cancel" event name.
         */
        "onExit"?: (event: VerdocsUploadDialogCustomEvent<any>) => void;
        /**
          * Event fired when the dialog is closed. The event data will contain the file selected.
         */
        "onNext"?: (event: VerdocsUploadDialogCustomEvent<IFileWithData[]>) => void;
    }
    /**
     * Render the documents attached to an envelope in read-only (view) mode. All documents are displayed in order.
     */
    interface VerdocsView {
        /**
          * The endpoint to use to communicate with Verdocs. If not set, the default endpoint will be used.
         */
        "endpoint"?: VerdocsEndpoint;
        /**
          * The envelope ID to render. Set ONE OF templateId or envelopeId. If both are set, envelopeId will be ignored.
         */
        "envelopeId"?: string;
        /**
          * If set, (recommended), the host application should create a <DIV> element with a unique ID. When this component renders, the header will be removed from its default location and placed in the target element. This allows the parent application to more easily control its placement and scroll effects (e.g. "fixed").  The movement of the header to the target container is not dynamic - it is performed only on the initial render. Host applications should not conditionally render this container. If the header's visibility must be externally controlled, use CSS display options to hide/show it instead.
         */
        "headerTargetId"?: string | null;
        /**
          * Event fired when the user clicks Send Another to proceed. It is up to the host application to redirect the user to the appropriate next workflow step.
         */
        "onAnother"?: (event: VerdocsViewCustomEvent<any>) => void;
        /**
          * Event fired when the envelope is updated in any way. May be used for tasks such as cache invalidation or reporting to other systems.
         */
        "onEnvelopeUpdated"?: (event: VerdocsViewCustomEvent<{endpoint: VerdocsEndpoint; envelope: IEnvelope; event: string}>) => void;
        /**
          * Event fired when the user clicks Done to proceed. It is up to the host application to redirect the user to the appropriate next workflow step.
         */
        "onNext"?: (event: VerdocsViewCustomEvent<any>) => void;
        /**
          * Event fired if an error occurs. The event details will contain information about the error. Most errors will terminate the process, and the calling application should correct the condition and re-render the component.
         */
        "onSdkError"?: (event: VerdocsViewCustomEvent<SDKError>) => void;
        /**
          * Event fired when the user clicks Send Another to proceed. It is up to the host application to redirect the user to the appropriate next workflow step.
         */
        "onView"?: (event: VerdocsViewCustomEvent<any>) => void;
    }
    interface IntrinsicElements {
        "verdocs-activity-box": VerdocsActivityBox;
        "verdocs-auth": VerdocsAuth;
        "verdocs-build": VerdocsBuild;
        "verdocs-button": VerdocsButton;
        "verdocs-button-panel": VerdocsButtonPanel;
        "verdocs-checkbox": VerdocsCheckbox;
        "verdocs-component-error": VerdocsComponentError;
        "verdocs-contact-picker": VerdocsContactPicker;
        "verdocs-dialog": VerdocsDialog;
        "verdocs-dropdown": VerdocsDropdown;
        "verdocs-envelope-document-page": VerdocsEnvelopeDocumentPage;
        "verdocs-envelope-recipient-link": VerdocsEnvelopeRecipientLink;
        "verdocs-envelope-recipient-summary": VerdocsEnvelopeRecipientSummary;
        "verdocs-envelope-sidebar": VerdocsEnvelopeSidebar;
        "verdocs-envelopes-list": VerdocsEnvelopesList;
        "verdocs-field-attachment": VerdocsFieldAttachment;
        "verdocs-field-checkbox": VerdocsFieldCheckbox;
        "verdocs-field-date": VerdocsFieldDate;
        "verdocs-field-dropdown": VerdocsFieldDropdown;
        "verdocs-field-initial": VerdocsFieldInitial;
        "verdocs-field-payment": VerdocsFieldPayment;
        "verdocs-field-radio-button": VerdocsFieldRadioButton;
        "verdocs-field-signature": VerdocsFieldSignature;
        "verdocs-field-textarea": VerdocsFieldTextarea;
        "verdocs-field-textbox": VerdocsFieldTextbox;
        "verdocs-field-timestamp": VerdocsFieldTimestamp;
        "verdocs-file-chooser": VerdocsFileChooser;
        "verdocs-help-icon": VerdocsHelpIcon;
        "verdocs-initial-dialog": VerdocsInitialDialog;
        "verdocs-kba-dialog": VerdocsKbaDialog;
        "verdocs-loader": VerdocsLoader;
        "verdocs-ok-dialog": VerdocsOkDialog;
        "verdocs-organization-card": VerdocsOrganizationCard;
        "verdocs-pagination": VerdocsPagination;
        "verdocs-portal": VerdocsPortal;
        "verdocs-preview": VerdocsPreview;
        "verdocs-progress-bar": VerdocsProgressBar;
        "verdocs-quick-filter": VerdocsQuickFilter;
        "verdocs-quick-functions": VerdocsQuickFunctions;
        "verdocs-radio-button": VerdocsRadioButton;
        "verdocs-search": VerdocsSearch;
        "verdocs-search-box": VerdocsSearchBox;
        "verdocs-search-tabs": VerdocsSearchTabs;
        "verdocs-select-input": VerdocsSelectInput;
        "verdocs-send": VerdocsSend;
        "verdocs-settings": VerdocsSettings;
        "verdocs-settings-api-keys": VerdocsSettingsApiKeys;
        "verdocs-settings-members": VerdocsSettingsMembers;
        "verdocs-settings-organization": VerdocsSettingsOrganization;
        "verdocs-settings-profile": VerdocsSettingsProfile;
        "verdocs-sign": VerdocsSign;
        "verdocs-signature-dialog": VerdocsSignatureDialog;
        "verdocs-spinner": VerdocsSpinner;
        "verdocs-status-indicator": VerdocsStatusIndicator;
        "verdocs-table": VerdocsTable;
        "verdocs-tabs": VerdocsTabs;
        "verdocs-template-attachments": VerdocsTemplateAttachments;
        "verdocs-template-build-tabs": VerdocsTemplateBuildTabs;
        "verdocs-template-card": VerdocsTemplateCard;
        "verdocs-template-create": VerdocsTemplateCreate;
        "verdocs-template-document-page": VerdocsTemplateDocumentPage;
        "verdocs-template-field-properties": VerdocsTemplateFieldProperties;
        "verdocs-template-fields": VerdocsTemplateFields;
        "verdocs-template-name": VerdocsTemplateName;
        "verdocs-template-reminders": VerdocsTemplateReminders;
        "verdocs-template-role-properties": VerdocsTemplateRoleProperties;
        "verdocs-template-roles": VerdocsTemplateRoles;
        "verdocs-template-sender": VerdocsTemplateSender;
        "verdocs-template-star": VerdocsTemplateStar;
        "verdocs-template-tags": VerdocsTemplateTags;
        "verdocs-template-visibility": VerdocsTemplateVisibility;
        "verdocs-templates-list": VerdocsTemplatesList;
        "verdocs-text-input": VerdocsTextInput;
        "verdocs-toggle": VerdocsToggle;
        "verdocs-toggle-button": VerdocsToggleButton;
        "verdocs-toolbar-icon": VerdocsToolbarIcon;
        "verdocs-upload-dialog": VerdocsUploadDialog;
        "verdocs-view": VerdocsView;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * Displays a box showing summaries of envelopes matching specified conditions. Activity Boxes show a fixed number
             * of items because they are meant to be laid out horizontally (if the user's screen is large enough) and this helps
             * them appear more visually balanced.
             */
            "verdocs-activity-box": LocalJSX.VerdocsActivityBox & JSXBase.HTMLAttributes<HTMLVerdocsActivityBoxElement>;
            /**
             * Display an authentication dialog that allows the user to login or sign up. If the user is already authenticated
             * with a valid session, this component will hide itself and fire the success callback immediately. It is up to the
             * host application to render the next appropriate view for the application.
             * To simplify UI development, a visibility flag can force this component to never display. This
             * allows you to susbcribe to notifications from client apps without calling the lower-level JS SDK.
             * This embed is responsive / mobile-friendly, but the calling application should provide at least a 300px wide
             * container to allow sufficient space for the required forms.
             * ```ts
             * <verdocs-auth onAuthenticated={e => console.log('Authentication state:', e.detail)} />
             * ```
             */
            "verdocs-auth": LocalJSX.VerdocsAuth & JSXBase.HTMLAttributes<HTMLVerdocsAuthElement>;
            /**
             * Display a template building experience.
             * ```ts
             * <verdocs-build templateId={templateId} />
             * ```
             */
            "verdocs-build": LocalJSX.VerdocsBuild & JSXBase.HTMLAttributes<HTMLVerdocsBuildElement>;
            /**
             * A simple button, with consistent styling to other controls in the design system.
             * ```ts
             * <verdocs-button label="Click Me" size="normal" variant="standard" />
             * ```
             */
            "verdocs-button": LocalJSX.VerdocsButton & JSXBase.HTMLAttributes<HTMLVerdocsButtonElement>;
            /**
             * Display an icon button that triggers a drop-down panel that can display
             * arbitrary child content, such as metadata, forms, or other controls.
             * ```ts
             *   <verdocs-button-panel .icon=${icon}>
             *     <h6>Field Settings</h6>
             *     <form>
             *     <p>
             *       <label>Field Name</label>
             *       <input type="text" placeholder="Field Name..." />
             *     </p>
             *     </form>
             *   </verdocs-button-panel>
             * ```
             */
            "verdocs-button-panel": LocalJSX.VerdocsButtonPanel & JSXBase.HTMLAttributes<HTMLVerdocsButtonPanelElement>;
            /**
             * Displays a check box. Note that this is different from the `verdocs-field-checkbox` component, which is designed
             * to be used in signing experiences and contains settings that connect to template fields. This is just a simple check
             * box for UI displays e.g. dialog boxes.
             * This control encapsulates a standard HTML checkbox. To subscribe to change events, connect an `onChange`
             * handler. Sample usage:
             * ```ts
             * <verdocs-checkbox
             *    value="on"
             *    name="thingEnabled"
             *    checked={this.thingEnabled}
             *    onInput={(e: any) => (this.thingEnabled = e.target.checked)}
             * />
             * ```
             */
            "verdocs-checkbox": LocalJSX.VerdocsCheckbox & JSXBase.HTMLAttributes<HTMLVerdocsCheckboxElement>;
            /**
             * Render a simple error message.
             */
            "verdocs-component-error": LocalJSX.VerdocsComponentError & JSXBase.HTMLAttributes<HTMLVerdocsComponentErrorElement>;
            /**
             * Displays a contact picker suitable for filling out Recipient objects when sending Documents.
             * This picker can also be integrated with a backend to provide contact list / suggestion / address-book style behavior. As the
             * user interacts with the component, the text entered in the name field is sent back to the parent via the `searchContacts` event.
             * The parent can use that text as a query string to call a backend to obtain appropriate contacts to show. This list may also be
             * hard-coded ahead of time to provide the user with smart suggestions on initial display, such as "Recently Used" contacts, or
             * to always display the user's own contact record.
             */
            "verdocs-contact-picker": LocalJSX.VerdocsContactPicker & JSXBase.HTMLAttributes<HTMLVerdocsContactPickerElement>;
            /**
             * Display a simple dialog where the contents are provided via slots.
             */
            "verdocs-dialog": LocalJSX.VerdocsDialog & JSXBase.HTMLAttributes<HTMLVerdocsDialogElement>;
            /**
             * Display a drop-down menu button. A menu of the specified options will be displayed when the button is pressed. The menu will be hidden
             * when the button is pressed again, or an option is selected. Separators may be created by supplying an entry with an empty label.
             * ```ts
             * <verdocs-dropdown
             *   options={[
             *     {label: 'Option 1', disabled: true},
             *     {label: 'Option 2', id: '2'}
             *     {label: ''}
             *     {label: 'Option 3', id: '2'}
             *    ]}
             *   label="OK" onClick={() => (console.log('OK clicked'))}
             * />
             * ```
             */
            "verdocs-dropdown": LocalJSX.VerdocsDropdown & JSXBase.HTMLAttributes<HTMLVerdocsDropdownElement>;
            /**
             * Represents one document page. This is primarily a layout container used to coordinate positions of
             * page-related layers such as the page itself, signature fields, etc. It is not intended to be used
             * on its own as an individual component.
             */
            "verdocs-envelope-document-page": LocalJSX.VerdocsEnvelopeDocumentPage & JSXBase.HTMLAttributes<HTMLVerdocsEnvelopeDocumentPageElement>;
            /**
             * Displays a single recipient from an envelope, with the opportunity to copy an in-person
             * signing link for that recipient to use.
             */
            "verdocs-envelope-recipient-link": LocalJSX.VerdocsEnvelopeRecipientLink & JSXBase.HTMLAttributes<HTMLVerdocsEnvelopeRecipientLinkElement>;
            /**
             * Displays a list of recipients with options to get in-person signing links for each one.
             */
            "verdocs-envelope-recipient-summary": LocalJSX.VerdocsEnvelopeRecipientSummary & JSXBase.HTMLAttributes<HTMLVerdocsEnvelopeRecipientSummaryElement>;
            /**
             * Displays a file upload mechanism suitable for the first step of creating a template.
             * This is typically the first step in a template creation workflow.
             */
            "verdocs-envelope-sidebar": LocalJSX.VerdocsEnvelopeSidebar & JSXBase.HTMLAttributes<HTMLVerdocsEnvelopeSidebarElement>;
            /**
             * Displays a list of envelopes matching specified conditions.
             */
            "verdocs-envelopes-list": LocalJSX.VerdocsEnvelopesList & JSXBase.HTMLAttributes<HTMLVerdocsEnvelopesListElement>;
            /**
             * Displays an attachment field.
             */
            "verdocs-field-attachment": LocalJSX.VerdocsFieldAttachment & JSXBase.HTMLAttributes<HTMLVerdocsFieldAttachmentElement>;
            /**
             * Displays a checkbox.
             */
            "verdocs-field-checkbox": LocalJSX.VerdocsFieldCheckbox & JSXBase.HTMLAttributes<HTMLVerdocsFieldCheckboxElement>;
            /**
             * Displays a date field. When tapped or clicked, the input element will display a date picker component.
             */
            "verdocs-field-date": LocalJSX.VerdocsFieldDate & JSXBase.HTMLAttributes<HTMLVerdocsFieldDateElement>;
            /**
             * Displays a dropdown field that allows the user to choose one of a list of options.
             */
            "verdocs-field-dropdown": LocalJSX.VerdocsFieldDropdown & JSXBase.HTMLAttributes<HTMLVerdocsFieldDropdownElement>;
            /**
             * Displays an initial field. If an initial already exists, it will be displayed and the field
             * will be disabled. Otherwise, a placeholder button will be shown. Clicking the button will
             * show a dialog to adopt an initial.
             * NOTE: When initial fields are completed they will be filled with an initial "stamp".
             * This requires operation against a live, valid envelope. If you are testing this component
             * in Storybook, it will not be visible here.
             */
            "verdocs-field-initial": LocalJSX.VerdocsFieldInitial & JSXBase.HTMLAttributes<HTMLVerdocsFieldInitialElement>;
            /**
             * Displays a signature field. Various field types are supported, including traditional Signature and Initials types as well as
             * input types like text and checkbox.
             */
            "verdocs-field-payment": LocalJSX.VerdocsFieldPayment & JSXBase.HTMLAttributes<HTMLVerdocsFieldPaymentElement>;
            /**
             * Displays a radio button.
             */
            "verdocs-field-radio-button": LocalJSX.VerdocsFieldRadioButton & JSXBase.HTMLAttributes<HTMLVerdocsFieldRadioButtonElement>;
            /**
             * Displays a signature field. If a signature already exists, it will be displayed and the field
             * will be disabled. Otherwise, a placeholder button will be shown. Clicking the button will
             * show a dialog to adopt a signature.
             * NOTE: When signature fields are completed they will be filled with a signature "stamp".
             * This requires operation against a live, valid envelope. If you are testing this component
             * in Storybook, it will not be visible here.
             */
            "verdocs-field-signature": LocalJSX.VerdocsFieldSignature & JSXBase.HTMLAttributes<HTMLVerdocsFieldSignatureElement>;
            /**
             * Display a multi-line text input field. Reminder: the "position" of the field is specified
             * as the BOTTOM-LEFT corner.
             */
            "verdocs-field-textarea": LocalJSX.VerdocsFieldTextarea & JSXBase.HTMLAttributes<HTMLVerdocsFieldTextareaElement>;
            /**
             * Display a simple 1-line text input field.
             */
            "verdocs-field-textbox": LocalJSX.VerdocsFieldTextbox & JSXBase.HTMLAttributes<HTMLVerdocsFieldTextboxElement>;
            /**
             * Display a timestamp. Timestamps are not editable by signers. Instead, they are automatically
             * filled when the signer submits the document.
             */
            "verdocs-field-timestamp": LocalJSX.VerdocsFieldTimestamp & JSXBase.HTMLAttributes<HTMLVerdocsFieldTimestampElement>;
            /**
             * Displays a file picker to upload an attachment. This component is just the picker - the host application or component should
             * provide the actual upload functionality.
             * ```ts
             * <verdocs-file-chooser onFileSelected={(e) => console.log('File Selected', e.detail)} />
             * ```
             */
            "verdocs-file-chooser": LocalJSX.VerdocsFileChooser & JSXBase.HTMLAttributes<HTMLVerdocsFileChooserElement>;
            /**
             * Displays a simple help icon. Upon hover or focus, a tooltip will be displayed with help text.
             * ```ts
             * <verdocs-help-icon text="Sample help text" />
             * ```
             */
            "verdocs-help-icon": LocalJSX.VerdocsHelpIcon & JSXBase.HTMLAttributes<HTMLVerdocsHelpIconElement>;
            /**
             * Display a dialog that allows the user to specify an initials image, either by using a signature-font-generated image
             * based on their full name, or by hand-drawing their initials with a mouse or tablet.
             */
            "verdocs-initial-dialog": LocalJSX.VerdocsInitialDialog & JSXBase.HTMLAttributes<HTMLVerdocsInitialDialogElement>;
            /**
             * Prompt the user to confirm their identity with a series of questions.
             */
            "verdocs-kba-dialog": LocalJSX.VerdocsKbaDialog & JSXBase.HTMLAttributes<HTMLVerdocsKbaDialogElement>;
            /**
             * Animated loader placeholder. There are currently no configuration options for this control.
             * ```ts
             * <verdocs-loader />
             * ```
             */
            "verdocs-loader": LocalJSX.VerdocsLoader & JSXBase.HTMLAttributes<HTMLVerdocsLoaderElement>;
            /**
             * Display a simple text dialog box with an Ok button. This adds a partially-transparent overlay and screen-centered dialog
             * box with a message and optional header/title. An OK button is shown that will dismiss the message.
             * It can also be dismissed by clicking the background overlay.
             */
            "verdocs-ok-dialog": LocalJSX.VerdocsOkDialog & JSXBase.HTMLAttributes<HTMLVerdocsOkDialogElement>;
            /**
             * Display a small summary card describing an organization.
             * ```ts
             * <verdocs-organization-card organization={organization} />
             * ```
             */
            "verdocs-organization-card": LocalJSX.VerdocsOrganizationCard & JSXBase.HTMLAttributes<HTMLVerdocsOrganizationCardElement>;
            /**
             * Display a simple pagination control with individual buttons to move through the data set.
             * ```ts
             * <verdocs-pagination
             *   selectedPage={1}
             *   itemCount={50}
             *   perPage={10}
             *   onSelectPage={(e) => {setSelectedpage(e.detail.selectedPage)}}
             * />
             * ```
             */
            "verdocs-pagination": LocalJSX.VerdocsPagination & JSXBase.HTMLAttributes<HTMLVerdocsPaginationElement>;
            /**
             * Display a child component in a "portal", popping it out of the main DOM tree
             * to allow it to escape the bounds set by its parent.
             * @credit https://github.com/tomas-teston/stencil-portal for the basic
             * technique. This has been altered in a few ways to make it more friendly
             * to cases where there may be multiple portals on the page and provide more
             * alignment options for the child to be displayed.
             * ```ts
             * <div style="padding: 40px">
             * <div id="sample-tooltip" style="border: 1px solid green; padding: 3px 10px;">
             * Tooltip Anchor
             * <verdocs-portal anchor="sample-tooltip" .align=${align} .voffset=${voffset}>
             * <div style="border: 1px solid red; padding: 3px 10px;">Tooltip</div>
             * </verdocs-portal>
             * </div>
             * </div>
             * ```
             */
            "verdocs-portal": LocalJSX.VerdocsPortal & JSXBase.HTMLAttributes<HTMLVerdocsPortalElement>;
            /**
             * Display a template preview experience. This will display the template's attached
             * documents with signing fields overlaid on each page. Fields will be color-coded
             * by recipient, and will be read-only (cannot be filled, moved, or altered).
             * ```ts
             * <verdocs-preview templateId={templateId} />
             * ```
             */
            "verdocs-preview": LocalJSX.VerdocsPreview & JSXBase.HTMLAttributes<HTMLVerdocsPreviewElement>;
            /**
             * Display a simple progress bar in a style consistent with the design system.
             * ```ts
             * <verdocs-progress-bar label="Uploading..." showPercent={true} percent={54} />
             * ```
             */
            "verdocs-progress-bar": LocalJSX.VerdocsProgressBar & JSXBase.HTMLAttributes<HTMLVerdocsProgressBarElement>;
            /**
             * Display a drop-down menu of quick filter options.
             * ```ts
             * <verdocs-quick-filter options={[...options]} value={1} label="Filter" placeholder="All" />
             * ```
             */
            "verdocs-quick-filter": LocalJSX.VerdocsQuickFilter & JSXBase.HTMLAttributes<HTMLVerdocsQuickFilterElement>;
            /**
             * Display quick-function buttons for creating templates and documents.
             * Authentication is required to demonstrate this Element. You may do this in Storybook by using the Auth
             * embed. This Element will reuse the same session produced by logging in via that Embed.
             */
            "verdocs-quick-functions": LocalJSX.VerdocsQuickFunctions & JSXBase.HTMLAttributes<HTMLVerdocsQuickFunctionsElement>;
            /**
             * Displays a radio button. Note that this is different from the `verdocs-field-radio-button` component, which is
             * designed to be used in signing experiences and contains settings that connect to template fields. This is just a
             * simple radio button for UI displays e.g. dialog boxes.
             * This control encapsulates a standard HTML radio button. To subscribe to change events, connect an `onChange`
             * handler. Sample usage:
             * ```ts
             * <verdocs-radio-button
             *    value="val1"
             *    name="someProperty"
             *    checked={this.someProperty === 'val1'}
             *    onInput={(e: any) => { this.someProperty = 'val1' }}
             *    disabled={false}
             * />
             * ```
             */
            "verdocs-radio-button": LocalJSX.VerdocsRadioButton & JSXBase.HTMLAttributes<HTMLVerdocsRadioButtonElement>;
            "verdocs-search": LocalJSX.VerdocsSearch & JSXBase.HTMLAttributes<HTMLVerdocsSearchElement>;
            /**
             * Displays a customizable input box for search queries.
             * Authentication is required to demonstrate this Element. You may do this in Storybook by using the Auth
             * embed. This Element will reuse the same session produced by logging in via that Embed.
             */
            "verdocs-search-box": LocalJSX.VerdocsSearchBox & JSXBase.HTMLAttributes<HTMLVerdocsSearchBoxElement>;
            "verdocs-search-tabs": LocalJSX.VerdocsSearchTabs & JSXBase.HTMLAttributes<HTMLVerdocsSearchTabsElement>;
            /**
             * Display a text input field. This is just a standard HTML input field with minimal markup to fit the
             * visual styles of the other components. Note that events "bubble" from the input field to the container,
             * so you can subscribe to the same DOM events (input, blur, etc) that a normal input would emit.
             * ```ts
             * <verdocs-select-input label="Select:" label="Select" options={[...options]}
             * @input ={() => {}} />
             * ```
             */
            "verdocs-select-input": LocalJSX.VerdocsSelectInput & JSXBase.HTMLAttributes<HTMLVerdocsSelectInputElement>;
            /**
             * Display a form to send a template to one or more recipients in an envelope for signing. Note
             * that because most applications have custom workflow requirements to trigger after sending an
             * Envelope, this component does not actually perform that operation. Parent applications should
             * listen for the `onSend` event, and can pass the contents of `event.detail` directly to the
             * `createEnvelope()` call in JS-SDK.
             * Host applications should ensure the template is "sendable" before displaying this component.
             * To be sendable, a template must have at least one document attached, at least one participant
             * defined, and at least one field assigned to every "signer" participant. This component will
             * hide itself if the template is not sendable.
             * ```ts
             * <verdocs-send templateId={templateId} />
             * ```
             */
            "verdocs-send": LocalJSX.VerdocsSend & JSXBase.HTMLAttributes<HTMLVerdocsSendElement>;
            /**
             * Display a template preview experience. This will display the template's attached
             * documents with signing fields overlaid on each page. Fields will be color-coded
             * by recipient, and will be read-only (cannot be filled, moved, or altered).
             * ```ts
             * <verdocs-settings />
             * ```
             */
            "verdocs-settings": LocalJSX.VerdocsSettings & JSXBase.HTMLAttributes<HTMLVerdocsSettingsElement>;
            /**
             * Displays a settings form that allows the user to manage their API keys.
             */
            "verdocs-settings-api-keys": LocalJSX.VerdocsSettingsApiKeys & JSXBase.HTMLAttributes<HTMLVerdocsSettingsApiKeysElement>;
            /**
             * Displays a settings form that allows the user to manage their Verdocs profile.
             */
            "verdocs-settings-members": LocalJSX.VerdocsSettingsMembers & JSXBase.HTMLAttributes<HTMLVerdocsSettingsMembersElement>;
            /**
             * Displays a settings form that allows the user to manage their Verdocs profile.
             */
            "verdocs-settings-organization": LocalJSX.VerdocsSettingsOrganization & JSXBase.HTMLAttributes<HTMLVerdocsSettingsOrganizationElement>;
            /**
             * Displays a settings form that allows the user to manage their Verdocs profile.
             */
            "verdocs-settings-profile": LocalJSX.VerdocsSettingsProfile & JSXBase.HTMLAttributes<HTMLVerdocsSettingsProfileElement>;
            /**
             * Display an envelope signing experience. This will display the envelope's attached
             * documents with signing fields overlaid on each page.
             * The component will attempt to initiate a signing session and load the specified
             * envelope. If successful, the recipient's fields will be enabled and the user will
             * be able to sign the envelope's attached documents. If not, an `sdkError` will be
             * thrown and the component will be blank/empty. To provide the best user experience,
             * applications should capture and handle this error to provide the user with
             * instructions/options for next steps based on the application's design and workflow.
             * Unlike other components, this will always create its own endpoint to manage the
             * session session. This endpoint will be included in event callbacks for the
             * convenience of host applications that may wish to make server calls using the
             * signer's credentials once signing is complete (e.g. to obtain copies of
             * the signed attachments.)
             */
            "verdocs-sign": LocalJSX.VerdocsSign & JSXBase.HTMLAttributes<HTMLVerdocsSignElement>;
            /**
             * Display a dialog that allows the user to specify a signature image, either by using a signature-font-generated image
             * based on their full name, or by hand-drawing their signature with a mouse or tablet.
             */
            "verdocs-signature-dialog": LocalJSX.VerdocsSignatureDialog & JSXBase.HTMLAttributes<HTMLVerdocsSignatureDialogElement>;
            /**
             * Display a small loading spinner.
             * ```ts
             * <verdocs-spinner />
             * ```
             */
            "verdocs-spinner": LocalJSX.VerdocsSpinner & JSXBase.HTMLAttributes<HTMLVerdocsSpinnerElement>;
            /**
             * Displays an icon and message describing a document's completion status. For convenience, the status may be passed in either
             * directly as a status field or the whole document object may be passed in.
             * If the document is provided, the status flag will indicate the document's overall status. This also makes the component clickable
             * to display a popup panel with per-recipient status data.
             * If the status is provided as a string it can be either a `TRecipientStatus` or `TDocumentStatus` value.
             */
            "verdocs-status-indicator": LocalJSX.VerdocsStatusIndicator & JSXBase.HTMLAttributes<HTMLVerdocsStatusIndicatorElement>;
            /**
             * Display a simple table of data. Columns and data cells may have custom renderers defined to
             * support creating interactive table layouts.
             * ```ts
             * <verdocs-table columns={[...columns]} data={[...data]} />
             * ```
             */
            "verdocs-table": LocalJSX.VerdocsTable & JSXBase.HTMLAttributes<HTMLVerdocsTableElement>;
            /**
             * Display a simple row of selectable tabs. This is a controlled element.
             * The parent must adjust selectedTab as selection events are fired.
             * ```ts
             * <verdocs-tabs tabs={[...tabs]} />
             * ```
             */
            "verdocs-tabs": LocalJSX.VerdocsTabs & JSXBase.HTMLAttributes<HTMLVerdocsTabsElement>;
            /**
             * Displays an edit form that allows the user to view, add, or remove a template's attachments.
             * Note that an active session and valid template ID must be supplied.
             */
            "verdocs-template-attachments": LocalJSX.VerdocsTemplateAttachments & JSXBase.HTMLAttributes<HTMLVerdocsTemplateAttachmentsElement>;
            /**
             * Display a set of tabs for the template builder.
             */
            "verdocs-template-build-tabs": LocalJSX.VerdocsTemplateBuildTabs & JSXBase.HTMLAttributes<HTMLVerdocsTemplateBuildTabsElement>;
            /**
             * Displays a summary of a template
             */
            "verdocs-template-card": LocalJSX.VerdocsTemplateCard & JSXBase.HTMLAttributes<HTMLVerdocsTemplateCardElement>;
            /**
             * Displays a file upload mechanism suitable for the first step of creating a template.
             * This is typically the first step in a template creation workflow.
             */
            "verdocs-template-create": LocalJSX.VerdocsTemplateCreate & JSXBase.HTMLAttributes<HTMLVerdocsTemplateCreateElement>;
            /**
             * Represents one document page. This is primarily a layout container used to coordinate positions of
             * page-related layers such as the page itself, signature fields, etc. It is not intended to be used
             * on its own as an individual component.
             */
            "verdocs-template-document-page": LocalJSX.VerdocsTemplateDocumentPage & JSXBase.HTMLAttributes<HTMLVerdocsTemplateDocumentPageElement>;
            /**
             * Displays an edit form that allows the user to adjust a field's settings.
             */
            "verdocs-template-field-properties": LocalJSX.VerdocsTemplateFieldProperties & JSXBase.HTMLAttributes<HTMLVerdocsTemplateFieldPropertiesElement>;
            /**
             * Displays a builder experience for laying out fields in a template. Note that this experience requires a large display area to
             * present all of the required controls, so it is primarily intended to be used in desktop environments.
             */
            "verdocs-template-fields": LocalJSX.VerdocsTemplateFields & JSXBase.HTMLAttributes<HTMLVerdocsTemplateFieldsElement>;
            /**
             * Displays an edit form that allows the user to rename a template. Note that an active session and valid template ID must be supplied.
             */
            "verdocs-template-name": LocalJSX.VerdocsTemplateName & JSXBase.HTMLAttributes<HTMLVerdocsTemplateNameElement>;
            /**
             * Displays an edit form that allows the user to adjust a template's reminders.
             */
            "verdocs-template-reminders": LocalJSX.VerdocsTemplateReminders & JSXBase.HTMLAttributes<HTMLVerdocsTemplateRemindersElement>;
            /**
             * Display an edit form that allows the user to adjust a role's setitngs.
             */
            "verdocs-template-role-properties": LocalJSX.VerdocsTemplateRoleProperties & JSXBase.HTMLAttributes<HTMLVerdocsTemplateRolePropertiesElement>;
            /**
             * Displays an edit form that allows the user to adjust a template's roles and workflow.
             */
            "verdocs-template-roles": LocalJSX.VerdocsTemplateRoles & JSXBase.HTMLAttributes<HTMLVerdocsTemplateRolesElement>;
            /**
             * Display a dialog that allows a template sender to be selected.
             */
            "verdocs-template-sender": LocalJSX.VerdocsTemplateSender & JSXBase.HTMLAttributes<HTMLVerdocsTemplateSenderElement>;
            /**
             * Displays a clickable star that allows users to mark frequently-used templates.
             */
            "verdocs-template-star": LocalJSX.VerdocsTemplateStar & JSXBase.HTMLAttributes<HTMLVerdocsTemplateStarElement>;
            /**
             * Displays a message listing a template's tags.
             */
            "verdocs-template-tags": LocalJSX.VerdocsTemplateTags & JSXBase.HTMLAttributes<HTMLVerdocsTemplateTagsElement>;
            /**
             * Displays an edit form that allows the user to adjust a template's visibility.
             */
            "verdocs-template-visibility": LocalJSX.VerdocsTemplateVisibility & JSXBase.HTMLAttributes<HTMLVerdocsTemplateVisibilityElement>;
            /**
             * Displays a list of envelopes matching specified conditions.
             */
            "verdocs-templates-list": LocalJSX.VerdocsTemplatesList & JSXBase.HTMLAttributes<HTMLVerdocsTemplatesListElement>;
            /**
             * Display a text input field. This is just a standard HTML input field with minimal markup to fit the
             * visual styles of the other components. Note that events "bubble" from the input field to the container,
             * so you can subscribe to the same DOM events (input, blur, etc) that a normal input would emit.
             * ```ts
             * <verdocs-text-input type="text" label="Name" placeholder="Enter your name..." value="" />
             * ```
             */
            "verdocs-text-input": LocalJSX.VerdocsTextInput & JSXBase.HTMLAttributes<HTMLVerdocsTextInputElement>;
            /**
             * Displays a label and a set of buttons, also allowing a default selection of a button.
             * ```ts
             * <verdocs-toggle options={[...options]} theme="light"></verdocs-toggle>
             * ```
             */
            "verdocs-toggle": LocalJSX.VerdocsToggle & JSXBase.HTMLAttributes<HTMLVerdocsToggleElement>;
            /**
             * Displays a single button that can be toggled on or off by clicking it.
             * ```ts
             * <verdocs-toggle-button icon={MessageIcon} size="normal" active={true} />
             * ```
             */
            "verdocs-toggle-button": LocalJSX.VerdocsToggleButton & JSXBase.HTMLAttributes<HTMLVerdocsToggleButtonElement>;
            /**
             * Displays a simple help icon. Upon hover or focus, a tooltip will be displayed with help text.
             * ```ts
             * <verdocs-toolbar-icon text="Sample tooltip text" icon={CalendarIcon} />
             * ```
             */
            "verdocs-toolbar-icon": LocalJSX.VerdocsToolbarIcon & JSXBase.HTMLAttributes<HTMLVerdocsToolbarIconElement>;
            /**
             * Display a file upload tool. Note that the file is not actually transmitted, so it may be used by
             * callers with a variety of workflows. Instead, data about the chosen file will be passed to the
             * caller via the onNext event handler.
             */
            "verdocs-upload-dialog": LocalJSX.VerdocsUploadDialog & JSXBase.HTMLAttributes<HTMLVerdocsUploadDialogElement>;
            /**
             * Render the documents attached to an envelope in read-only (view) mode. All documents are displayed in order.
             */
            "verdocs-view": LocalJSX.VerdocsView & JSXBase.HTMLAttributes<HTMLVerdocsViewElement>;
        }
    }
}
